/**
 * Generated by orval v7.9.0 ðŸº
 * Do not edit manually.
 * HackerLab API
 * æ™ºèƒ½æ”»é˜²é¶åœºç®¡ç†API
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { docker_manager_api } from '../utils/docker-manager-api';
/**
 * æ‰€æœ‰å®¹å™¨æ•°æ®åŒ…æ–‡ä»¶å“åº”æ¨¡åž‹
 */
export interface AllPacketFilesResponse {
  /** æ¨¡åž‹ID */
  model_id: string;
  /** æ‰€æœ‰å®¹å™¨çš„æ•°æ®åŒ…æ–‡ä»¶åˆ—è¡¨ */
  packet_files: PacketFileResponse[];
  /** æ€»æ–‡ä»¶æ•°é‡ */
  total_count: number;
}

/**
 * å“åº”æ•°æ®
 */
export type ApiResponseData = unknown | null;

/**
 * ç»Ÿä¸€APIå“åº”æ ¼å¼
 */
export interface ApiResponse {
  /** çŠ¶æ€ç  */
  code?: number;
  /** å“åº”æ¶ˆæ¯ */
  message?: string;
  /** å“åº”æ•°æ® */
  data?: ApiResponseData;
}

/**
 * å“åº”æ•°æ®
 */
export type ApiResponseAllPacketFilesResponseData = AllPacketFilesResponse | null;

export interface ApiResponseAllPacketFilesResponse {
  /** çŠ¶æ€ç  */
  code?: number;
  /** å“åº”æ¶ˆæ¯ */
  message?: string;
  /** å“åº”æ•°æ® */
  data?: ApiResponseAllPacketFilesResponseData;
}

export type ApiResponseDictDataAnyOf = { [key: string]: unknown };

/**
 * å“åº”æ•°æ®
 */
export type ApiResponseDictData = ApiResponseDictDataAnyOf | null;

export interface ApiResponseDict {
  /** çŠ¶æ€ç  */
  code?: number;
  /** å“åº”æ¶ˆæ¯ */
  message?: string;
  /** å“åº”æ•°æ® */
  data?: ApiResponseDictData;
}

/**
 * å“åº”æ•°æ®
 */
export type ApiResponseGetDataFileContentResponseData = GetDataFileContentResponse | null;

export interface ApiResponseGetDataFileContentResponse {
  /** çŠ¶æ€ç  */
  code?: number;
  /** å“åº”æ¶ˆæ¯ */
  message?: string;
  /** å“åº”æ•°æ® */
  data?: ApiResponseGetDataFileContentResponseData;
}

/**
 * å“åº”æ•°æ®
 */
export type ApiResponseGetDataFileTreeResponseData = GetDataFileTreeResponse | null;

export interface ApiResponseGetDataFileTreeResponse {
  /** çŠ¶æ€ç  */
  code?: number;
  /** å“åº”æ¶ˆæ¯ */
  message?: string;
  /** å“åº”æ•°æ® */
  data?: ApiResponseGetDataFileTreeResponseData;
}

/**
 * å“åº”æ•°æ®
 */
export type ApiResponseGetModelAllContainerInspectResponseData = GetModelAllContainerInspectResponse | null;

export interface ApiResponseGetModelAllContainerInspectResponse {
  /** çŠ¶æ€ç  */
  code?: number;
  /** å“åº”æ¶ˆæ¯ */
  message?: string;
  /** å“åº”æ•°æ® */
  data?: ApiResponseGetModelAllContainerInspectResponseData;
}

/**
 * å“åº”æ•°æ®
 */
export type ApiResponseGetModelContainerInspectResponseData = GetModelContainerInspectResponse | null;

export interface ApiResponseGetModelContainerInspectResponse {
  /** çŠ¶æ€ç  */
  code?: number;
  /** å“åº”æ¶ˆæ¯ */
  message?: string;
  /** å“åº”æ•°æ® */
  data?: ApiResponseGetModelContainerInspectResponseData;
}

/**
 * å“åº”æ•°æ®
 */
export type ApiResponseListModelResponseData = ModelResponse[] | null;

export interface ApiResponseListModelResponse {
  /** çŠ¶æ€ç  */
  code?: number;
  /** å“åº”æ¶ˆæ¯ */
  message?: string;
  /** å“åº”æ•°æ® */
  data?: ApiResponseListModelResponseData;
}

/**
 * å“åº”æ•°æ®
 */
export type ApiResponseModelDeleteResponseData = ModelDeleteResponse | null;

export interface ApiResponseModelDeleteResponse {
  /** çŠ¶æ€ç  */
  code?: number;
  /** å“åº”æ¶ˆæ¯ */
  message?: string;
  /** å“åº”æ•°æ® */
  data?: ApiResponseModelDeleteResponseData;
}

/**
 * å“åº”æ•°æ®
 */
export type ApiResponseModelDetailResponseData = ModelDetailResponse | null;

export interface ApiResponseModelDetailResponse {
  /** çŠ¶æ€ç  */
  code?: number;
  /** å“åº”æ¶ˆæ¯ */
  message?: string;
  /** å“åº”æ•°æ® */
  data?: ApiResponseModelDetailResponseData;
}

/**
 * å“åº”æ•°æ®
 */
export type ApiResponseModelResponseData = ModelResponse | null;

export interface ApiResponseModelResponse {
  /** çŠ¶æ€ç  */
  code?: number;
  /** å“åº”æ¶ˆæ¯ */
  message?: string;
  /** å“åº”æ•°æ® */
  data?: ApiResponseModelResponseData;
}

/**
 * å“åº”æ•°æ®
 */
export type ApiResponseModelStateResponseData = ModelStateResponse | null;

export interface ApiResponseModelStateResponse {
  /** çŠ¶æ€ç  */
  code?: number;
  /** å“åº”æ¶ˆæ¯ */
  message?: string;
  /** å“åº”æ•°æ® */
  data?: ApiResponseModelStateResponseData;
}

/**
 * å“åº”æ•°æ®
 */
export type ApiResponsePacketFileResponseData = PacketFileResponse | null;

export interface ApiResponsePacketFileResponse {
  /** çŠ¶æ€ç  */
  code?: number;
  /** å“åº”æ¶ˆæ¯ */
  message?: string;
  /** å“åº”æ•°æ® */
  data?: ApiResponsePacketFileResponseData;
}

/**
 * åœºæ™¯çŠ¶æ€æžšä¸¾
 */
export type BaseState = typeof BaseState[keyof typeof BaseState];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BaseState = {
  pending: 'pending',
  building: 'building',
  running: 'running',
  stopped: 'stopped',
  build_error: 'build_error',
  runtime_error: 'runtime_error',
  error: 'error',
} as const;

export interface BodyCreateModelsModelsPost {
  /** æ¨¡åž‹åç§° */
  name: string;
  /** æ¨¡åž‹æè¿° */
  description: string;
  /** æ¨¡åž‹ç±»åž‹: scenario æˆ– exercise */
  model_type: string;
  /** æ”»å‡»ç«¯åŽ‹ç¼©åŒ…ï¼ˆåœºæ™¯å¿…éœ€ï¼‰ */
  attacker_file?: Blob;
  /** é˜²å®ˆç«¯åŽ‹ç¼©åŒ…ï¼ˆåœºæ™¯å¿…éœ€ï¼‰ */
  defender_file?: Blob;
  /** é¶æœºåŽ‹ç¼©åŒ… */
  target_file: Blob;
}

export interface BodyUploadModelFileModelsModelIdFilesUploadPost {
  /** è¦ä¸Šä¼ çš„æ–‡ä»¶ */
  file: Blob;
  /** æ–‡ä»¶ä¿å­˜è·¯å¾„ */
  file_path: string;
}

/**
 * åˆ›å»ºåœºæ™¯æ•°æ®ç›®å½•è¯·æ±‚æ¨¡åž‹
 */
export interface CreateDataDirectoryRequest {
  /** ç›®å½•è·¯å¾„ */
  dir_path: string;
}

/**
 * æ–‡ä»¶ç±»åž‹ï¼Œtextè¡¨ç¤ºæ–‡æœ¬æ–‡ä»¶ï¼Œbinaryè¡¨ç¤ºäºŒè¿›åˆ¶æ–‡ä»¶
 */
export type CreateDataFileRequestFileType = typeof CreateDataFileRequestFileType[keyof typeof CreateDataFileRequestFileType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateDataFileRequestFileType = {
  text: 'text',
  binary: 'binary',
} as const;

/**
 * åˆ›å»ºåœºæ™¯æ•°æ®æ–‡ä»¶è¯·æ±‚æ¨¡åž‹
 */
export interface CreateDataFileRequest {
  /** æ–‡ä»¶è·¯å¾„ */
  file_path: string;
  /** æ–‡ä»¶å†…å®¹ */
  content: string;
  /** æ–‡ä»¶ç±»åž‹ï¼Œtextè¡¨ç¤ºæ–‡æœ¬æ–‡ä»¶ï¼Œbinaryè¡¨ç¤ºäºŒè¿›åˆ¶æ–‡ä»¶ */
  file_type: CreateDataFileRequestFileType;
}

/**
 * åˆ é™¤åœºæ™¯æ•°æ®æ–‡ä»¶ç›®å½•è¯·æ±‚æ¨¡åž‹
 */
export interface DeleteDataFileRequest {
  /** æ–‡ä»¶è·¯å¾„ */
  file_path: string;
}

/**
 * èŽ·å–åœºæ™¯æ•°æ®æ–‡ä»¶å†…å®¹è¯·æ±‚æ¨¡åž‹
 */
export interface GetDataFileContentRequest {
  /** æ–‡ä»¶è·¯å¾„ */
  file_path: string;
}

/**
 * æ–‡ä»¶ç±»åž‹ï¼Œtextè¡¨ç¤ºæ–‡æœ¬æ–‡ä»¶ï¼Œbinaryè¡¨ç¤ºäºŒè¿›åˆ¶æ–‡ä»¶
 */
export type GetDataFileContentResponseFileType = typeof GetDataFileContentResponseFileType[keyof typeof GetDataFileContentResponseFileType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetDataFileContentResponseFileType = {
  text: 'text',
  binary: 'binary',
} as const;

/**
 * èŽ·å–åœºæ™¯æ•°æ®æ–‡ä»¶å†…å®¹å“åº”æ¨¡åž‹
 */
export interface GetDataFileContentResponse {
  /** æ–‡ä»¶å†…å®¹ */
  content: string;
  /** æ–‡ä»¶ç±»åž‹ï¼Œtextè¡¨ç¤ºæ–‡æœ¬æ–‡ä»¶ï¼Œbinaryè¡¨ç¤ºäºŒè¿›åˆ¶æ–‡ä»¶ */
  file_type: GetDataFileContentResponseFileType;
}

/**
 * æ–‡ä»¶æ ‘ç»“æž„ï¼Œé”®ä¸ºç›®å½•æˆ–æ–‡ä»¶åï¼Œå€¼ä¸ºå­ç›®å½•æˆ–æ–‡ä»¶åˆ—è¡¨
 */
export type GetDataFileTreeResponseFileTree = { [key: string]: unknown };

/**
 * èŽ·å–åœºæ™¯æ•°æ®æ–‡ä»¶æ ‘å“åº”æ¨¡åž‹
 */
export interface GetDataFileTreeResponse {
  /** æ–‡ä»¶æ ‘ç»“æž„ï¼Œé”®ä¸ºç›®å½•æˆ–æ–‡ä»¶åï¼Œå€¼ä¸ºå­ç›®å½•æˆ–æ–‡ä»¶åˆ—è¡¨ */
  file_tree: GetDataFileTreeResponseFileTree;
}

/**
 * æ‰€æœ‰å®¹å™¨è¯¦ç»†ä¿¡æ¯ï¼Œæ ¼å¼ä¸º {å®¹å™¨å: inspectä¿¡æ¯}
 */
export type GetModelAllContainerInspectResponseContainers = { [key: string]: unknown };

/**
 * èŽ·å–æ¨¡åž‹æ‰€æœ‰å®¹å™¨è¯¦ç»†ä¿¡æ¯å“åº”æ¨¡åž‹
 */
export interface GetModelAllContainerInspectResponse {
  /** æ¨¡åž‹ID */
  model_id: string;
  /** æ‰€æœ‰å®¹å™¨è¯¦ç»†ä¿¡æ¯ï¼Œæ ¼å¼ä¸º {å®¹å™¨å: inspectä¿¡æ¯} */
  containers: GetModelAllContainerInspectResponseContainers;
}

/**
 * å®¹å™¨è¯¦ç»†ä¿¡æ¯
 */
export type GetModelContainerInspectResponseInspect = { [key: string]: unknown };

/**
 * èŽ·å–æ¨¡åž‹å®¹å™¨è¯¦ç»†ä¿¡æ¯å“åº”æ¨¡åž‹
 */
export interface GetModelContainerInspectResponse {
  /** æ¨¡åž‹ID */
  model_id: string;
  /** å®¹å™¨åç§° */
  container_name: string;
  /** å®¹å™¨è¯¦ç»†ä¿¡æ¯ */
  inspect: GetModelContainerInspectResponseInspect;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

/**
 * åœºæ™¯æ“ä½œæžšä¸¾
 */
export type ModelAction = typeof ModelAction[keyof typeof ModelAction];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelAction = {
  start: 'start',
  stop: 'stop',
  build: 'build',
  force_stop_build: 'force_stop_build',
} as const;

/**
 * æ¨¡åž‹åˆ é™¤å“åº”æ¨¡åž‹
 */
export interface ModelDeleteResponse {
  deleted_model_id: string;
}

/**
 * Composeå†…å®¹
 */
export type ModelDetailResponseComposeInfo = { [key: string]: unknown };

/**
 * æ¨¡åž‹è¯¦ç»†ä¿¡æ¯å“åº”æ¨¡åž‹
 */
export interface ModelDetailResponse {
  uuid: string;
  name: string;
  description: string;
  state: BaseState;
  /** æ¨¡åž‹ç±»åž‹ï¼šscenario æˆ– exercise */
  model_type: string;
  data_path: string;
  /** Composeå†…å®¹ */
  compose_info: ModelDetailResponseComposeInfo;
}

/**
 * æ¨¡åž‹å“åº”æ¨¡åž‹
 */
export interface ModelResponse {
  uuid: string;
  name: string;
  description: string;
  state: BaseState;
  /** æ¨¡åž‹ç±»åž‹ï¼šscenario æˆ– exercise */
  model_type: string;
}

/**
 * æ¨¡åž‹çŠ¶æ€å“åº”æ¨¡åž‹
 */
export interface ModelStateResponse {
  uuid: string;
  state: BaseState;
}

/**
 * æ•°æ®åŒ…æ–‡ä»¶å“åº”æ¨¡åž‹
 */
export interface PacketFileResponse {
  /** å®¹å™¨åç§° */
  container_name: string;
  /** æ•°æ®åŒ…æ–‡ä»¶è·¯å¾„ */
  file_path: string;
  /** æ•°æ®åŒ…æ–‡ä»¶å */
  file_name: string;
  /** æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰ */
  file_size: number;
  /** åˆ›å»ºæ—¶é—´ */
  created_time: string;
  /** æ–‡ä»¶æ˜¯å¦å­˜åœ¨ */
  exists: boolean;
}

/**
 * æ–‡ä»¶ç±»åž‹ï¼Œtextè¡¨ç¤ºæ–‡æœ¬æ–‡ä»¶ï¼Œbinaryè¡¨ç¤ºäºŒè¿›åˆ¶æ–‡ä»¶
 */
export type UpdateDataFileRequestFileType = typeof UpdateDataFileRequestFileType[keyof typeof UpdateDataFileRequestFileType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UpdateDataFileRequestFileType = {
  text: 'text',
  binary: 'binary',
} as const;

/**
 * æ›´æ–°åœºæ™¯æ•°æ®æ–‡ä»¶è¯·æ±‚æ¨¡åž‹
 */
export interface UpdateDataFileRequest {
  /** æ–‡ä»¶è·¯å¾„ */
  file_path: string;
  /** æ–‡ä»¶å†…å®¹ */
  content: string;
  /** æ–‡ä»¶ç±»åž‹ï¼Œtextè¡¨ç¤ºæ–‡æœ¬æ–‡ä»¶ï¼Œbinaryè¡¨ç¤ºäºŒè¿›åˆ¶æ–‡ä»¶ */
  file_type: UpdateDataFileRequestFileType;
}

/**
 * æ¨¡åž‹åç§°, å¯é€‰
 */
export type UpdateModelRequestName = string | null;

/**
 * æ¨¡åž‹æè¿°, å¯é€‰
 */
export type UpdateModelRequestDescription = string | null;

/**
 * æ›´æ–°æ¨¡åž‹ä¿¡æ¯è¯·æ±‚æ¨¡åž‹
 */
export interface UpdateModelRequest {
  /** æ¨¡åž‹åç§°, å¯é€‰ */
  name?: UpdateModelRequestName;
  /** æ¨¡åž‹æè¿°, å¯é€‰ */
  description?: UpdateModelRequestDescription;
}

/**
 * æ›´æ–°æ¨¡åž‹çŠ¶æ€è¯·æ±‚æ¨¡åž‹
 */
export interface UpdateModelStateRequest {
  /** è¦æ‰§è¡Œçš„æ“ä½œ */
  action: ModelAction;
}

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

/**
 * èŽ·å–æ‰€æœ‰æ¨¡åž‹åˆ—è¡¨
 * @summary Get Models
 */
export const getModelsModelsGet = (
    
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<ApiResponseListModelResponse>(
      {url: `/models`, method: 'GET', signal
    },
      );
    }
  

export const getGetModelsModelsGetQueryKey = () => {
    return [`/models`] as const;
    }

    
export const getGetModelsModelsGetQueryOptions = <TData = Awaited<ReturnType<typeof getModelsModelsGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelsModelsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModelsModelsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModelsModelsGet>>> = ({ signal }) => getModelsModelsGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getModelsModelsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModelsModelsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getModelsModelsGet>>>
export type GetModelsModelsGetQueryError = unknown


export function useGetModelsModelsGet<TData = Awaited<ReturnType<typeof getModelsModelsGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelsModelsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModelsModelsGet>>,
          TError,
          Awaited<ReturnType<typeof getModelsModelsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModelsModelsGet<TData = Awaited<ReturnType<typeof getModelsModelsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelsModelsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModelsModelsGet>>,
          TError,
          Awaited<ReturnType<typeof getModelsModelsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModelsModelsGet<TData = Awaited<ReturnType<typeof getModelsModelsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelsModelsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Models
 */

export function useGetModelsModelsGet<TData = Awaited<ReturnType<typeof getModelsModelsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelsModelsGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModelsModelsGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * èŽ·å–æŒ‡å®šæ¨¡åž‹è¯¦æƒ…
 * @summary Get Model
 */
export const getModelModelsModelIdGet = (
    modelId: string,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<ApiResponseModelDetailResponse>(
      {url: `/models/${modelId}`, method: 'GET', signal
    },
      );
    }
  

export const getGetModelModelsModelIdGetQueryKey = (modelId: string,) => {
    return [`/models/${modelId}`] as const;
    }

    
export const getGetModelModelsModelIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getModelModelsModelIdGet>>, TError = HTTPValidationError>(modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelModelsModelIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModelModelsModelIdGetQueryKey(modelId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModelModelsModelIdGet>>> = ({ signal }) => getModelModelsModelIdGet(modelId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(modelId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getModelModelsModelIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModelModelsModelIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getModelModelsModelIdGet>>>
export type GetModelModelsModelIdGetQueryError = HTTPValidationError


export function useGetModelModelsModelIdGet<TData = Awaited<ReturnType<typeof getModelModelsModelIdGet>>, TError = HTTPValidationError>(
 modelId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelModelsModelIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModelModelsModelIdGet>>,
          TError,
          Awaited<ReturnType<typeof getModelModelsModelIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModelModelsModelIdGet<TData = Awaited<ReturnType<typeof getModelModelsModelIdGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelModelsModelIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModelModelsModelIdGet>>,
          TError,
          Awaited<ReturnType<typeof getModelModelsModelIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModelModelsModelIdGet<TData = Awaited<ReturnType<typeof getModelModelsModelIdGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelModelsModelIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Model
 */

export function useGetModelModelsModelIdGet<TData = Awaited<ReturnType<typeof getModelModelsModelIdGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelModelsModelIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModelModelsModelIdGetQueryOptions(modelId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * åˆ é™¤æ¨¡åž‹
 * @summary Delete Model
 */
export const deleteModelModelsModelIdDelete = (
    modelId: string,
 ) => {
      
      
      return docker_manager_api<ApiResponseModelDeleteResponse>(
      {url: `/models/${modelId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteModelModelsModelIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteModelModelsModelIdDelete>>, TError,{modelId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteModelModelsModelIdDelete>>, TError,{modelId: string}, TContext> => {

const mutationKey = ['deleteModelModelsModelIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteModelModelsModelIdDelete>>, {modelId: string}> = (props) => {
          const {modelId} = props ?? {};

          return  deleteModelModelsModelIdDelete(modelId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteModelModelsModelIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteModelModelsModelIdDelete>>>
    
    export type DeleteModelModelsModelIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Model
 */
export const useDeleteModelModelsModelIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteModelModelsModelIdDelete>>, TError,{modelId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteModelModelsModelIdDelete>>,
        TError,
        {modelId: string},
        TContext
      > => {

      const mutationOptions = getDeleteModelModelsModelIdDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * æ›´æ–°æ¨¡åž‹ä¿¡æ¯
 * @summary Update Model
 */
export const updateModelModelsModelIdPut = (
    modelId: string,
    updateModelRequest: UpdateModelRequest,
 ) => {
      
      
      return docker_manager_api<ApiResponseModelResponse>(
      {url: `/models/${modelId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateModelRequest
    },
      );
    }
  


export const getUpdateModelModelsModelIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateModelModelsModelIdPut>>, TError,{modelId: string;data: UpdateModelRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateModelModelsModelIdPut>>, TError,{modelId: string;data: UpdateModelRequest}, TContext> => {

const mutationKey = ['updateModelModelsModelIdPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateModelModelsModelIdPut>>, {modelId: string;data: UpdateModelRequest}> = (props) => {
          const {modelId,data} = props ?? {};

          return  updateModelModelsModelIdPut(modelId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateModelModelsModelIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateModelModelsModelIdPut>>>
    export type UpdateModelModelsModelIdPutMutationBody = UpdateModelRequest
    export type UpdateModelModelsModelIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Model
 */
export const useUpdateModelModelsModelIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateModelModelsModelIdPut>>, TError,{modelId: string;data: UpdateModelRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateModelModelsModelIdPut>>,
        TError,
        {modelId: string;data: UpdateModelRequest},
        TContext
      > => {

      const mutationOptions = getUpdateModelModelsModelIdPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * æ›´æ–°æ¨¡åž‹çŠ¶æ€
 * @summary Update Model State
 */
export const updateModelStateModelsModelIdPatch = (
    modelId: string,
    updateModelStateRequest: UpdateModelStateRequest,
 ) => {
      
      
      return docker_manager_api<ApiResponseModelResponse>(
      {url: `/models/${modelId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateModelStateRequest
    },
      );
    }
  


export const getUpdateModelStateModelsModelIdPatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateModelStateModelsModelIdPatch>>, TError,{modelId: string;data: UpdateModelStateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateModelStateModelsModelIdPatch>>, TError,{modelId: string;data: UpdateModelStateRequest}, TContext> => {

const mutationKey = ['updateModelStateModelsModelIdPatch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateModelStateModelsModelIdPatch>>, {modelId: string;data: UpdateModelStateRequest}> = (props) => {
          const {modelId,data} = props ?? {};

          return  updateModelStateModelsModelIdPatch(modelId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateModelStateModelsModelIdPatchMutationResult = NonNullable<Awaited<ReturnType<typeof updateModelStateModelsModelIdPatch>>>
    export type UpdateModelStateModelsModelIdPatchMutationBody = UpdateModelStateRequest
    export type UpdateModelStateModelsModelIdPatchMutationError = HTTPValidationError

    /**
 * @summary Update Model State
 */
export const useUpdateModelStateModelsModelIdPatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateModelStateModelsModelIdPatch>>, TError,{modelId: string;data: UpdateModelStateRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateModelStateModelsModelIdPatch>>,
        TError,
        {modelId: string;data: UpdateModelStateRequest},
        TContext
      > => {

      const mutationOptions = getUpdateModelStateModelsModelIdPatchMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * èŽ·å–æŒ‡å®šæ¨¡åž‹çŠ¶æ€
 * @summary Get Model State
 */
export const getModelStateModelsModelIdStateGet = (
    modelId: string,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<ApiResponseModelStateResponse>(
      {url: `/models/${modelId}/state`, method: 'GET', signal
    },
      );
    }
  

export const getGetModelStateModelsModelIdStateGetQueryKey = (modelId: string,) => {
    return [`/models/${modelId}/state`] as const;
    }

    
export const getGetModelStateModelsModelIdStateGetQueryOptions = <TData = Awaited<ReturnType<typeof getModelStateModelsModelIdStateGet>>, TError = HTTPValidationError>(modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelStateModelsModelIdStateGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModelStateModelsModelIdStateGetQueryKey(modelId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModelStateModelsModelIdStateGet>>> = ({ signal }) => getModelStateModelsModelIdStateGet(modelId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(modelId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getModelStateModelsModelIdStateGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModelStateModelsModelIdStateGetQueryResult = NonNullable<Awaited<ReturnType<typeof getModelStateModelsModelIdStateGet>>>
export type GetModelStateModelsModelIdStateGetQueryError = HTTPValidationError


export function useGetModelStateModelsModelIdStateGet<TData = Awaited<ReturnType<typeof getModelStateModelsModelIdStateGet>>, TError = HTTPValidationError>(
 modelId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelStateModelsModelIdStateGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModelStateModelsModelIdStateGet>>,
          TError,
          Awaited<ReturnType<typeof getModelStateModelsModelIdStateGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModelStateModelsModelIdStateGet<TData = Awaited<ReturnType<typeof getModelStateModelsModelIdStateGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelStateModelsModelIdStateGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModelStateModelsModelIdStateGet>>,
          TError,
          Awaited<ReturnType<typeof getModelStateModelsModelIdStateGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModelStateModelsModelIdStateGet<TData = Awaited<ReturnType<typeof getModelStateModelsModelIdStateGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelStateModelsModelIdStateGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Model State
 */

export function useGetModelStateModelsModelIdStateGet<TData = Awaited<ReturnType<typeof getModelStateModelsModelIdStateGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelStateModelsModelIdStateGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModelStateModelsModelIdStateGetQueryOptions(modelId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * åˆ›å»ºæ–°æ¨¡åž‹ï¼ˆæ”¯æŒåœºæ™¯/ç»ƒä¹ ï¼‰
 * @summary Create Models
 */
export const createModelsModelsPost = (
    bodyCreateModelsModelsPost: BodyCreateModelsModelsPost,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`name`, bodyCreateModelsModelsPost.name)
formData.append(`description`, bodyCreateModelsModelsPost.description)
formData.append(`model_type`, bodyCreateModelsModelsPost.model_type)
if(bodyCreateModelsModelsPost.attacker_file !== undefined) {
 formData.append(`attacker_file`, bodyCreateModelsModelsPost.attacker_file)
 }
if(bodyCreateModelsModelsPost.defender_file !== undefined) {
 formData.append(`defender_file`, bodyCreateModelsModelsPost.defender_file)
 }
formData.append(`target_file`, bodyCreateModelsModelsPost.target_file)

      return docker_manager_api<ApiResponseModelResponse>(
      {url: `/models/`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getCreateModelsModelsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createModelsModelsPost>>, TError,{data: BodyCreateModelsModelsPost}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createModelsModelsPost>>, TError,{data: BodyCreateModelsModelsPost}, TContext> => {

const mutationKey = ['createModelsModelsPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createModelsModelsPost>>, {data: BodyCreateModelsModelsPost}> = (props) => {
          const {data} = props ?? {};

          return  createModelsModelsPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateModelsModelsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createModelsModelsPost>>>
    export type CreateModelsModelsPostMutationBody = BodyCreateModelsModelsPost
    export type CreateModelsModelsPostMutationError = HTTPValidationError

    /**
 * @summary Create Models
 */
export const useCreateModelsModelsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createModelsModelsPost>>, TError,{data: BodyCreateModelsModelsPost}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createModelsModelsPost>>,
        TError,
        {data: BodyCreateModelsModelsPost},
        TContext
      > => {

      const mutationOptions = getCreateModelsModelsPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * èŽ·å–æ¨¡åž‹å®¹å™¨è¯¦ç»†ä¿¡æ¯
 * @summary Get Model Container Inspect
 */
export const getModelContainerInspectModelsModelIdInspectContainerNameGet = (
    modelId: string,
    containerName: string,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<ApiResponseGetModelContainerInspectResponse>(
      {url: `/models/${modelId}/inspect/${containerName}`, method: 'GET', signal
    },
      );
    }
  

export const getGetModelContainerInspectModelsModelIdInspectContainerNameGetQueryKey = (modelId: string,
    containerName: string,) => {
    return [`/models/${modelId}/inspect/${containerName}`] as const;
    }

    
export const getGetModelContainerInspectModelsModelIdInspectContainerNameGetQueryOptions = <TData = Awaited<ReturnType<typeof getModelContainerInspectModelsModelIdInspectContainerNameGet>>, TError = HTTPValidationError>(modelId: string,
    containerName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelContainerInspectModelsModelIdInspectContainerNameGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModelContainerInspectModelsModelIdInspectContainerNameGetQueryKey(modelId,containerName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModelContainerInspectModelsModelIdInspectContainerNameGet>>> = ({ signal }) => getModelContainerInspectModelsModelIdInspectContainerNameGet(modelId,containerName, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(modelId && containerName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getModelContainerInspectModelsModelIdInspectContainerNameGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModelContainerInspectModelsModelIdInspectContainerNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof getModelContainerInspectModelsModelIdInspectContainerNameGet>>>
export type GetModelContainerInspectModelsModelIdInspectContainerNameGetQueryError = HTTPValidationError


export function useGetModelContainerInspectModelsModelIdInspectContainerNameGet<TData = Awaited<ReturnType<typeof getModelContainerInspectModelsModelIdInspectContainerNameGet>>, TError = HTTPValidationError>(
 modelId: string,
    containerName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelContainerInspectModelsModelIdInspectContainerNameGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModelContainerInspectModelsModelIdInspectContainerNameGet>>,
          TError,
          Awaited<ReturnType<typeof getModelContainerInspectModelsModelIdInspectContainerNameGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModelContainerInspectModelsModelIdInspectContainerNameGet<TData = Awaited<ReturnType<typeof getModelContainerInspectModelsModelIdInspectContainerNameGet>>, TError = HTTPValidationError>(
 modelId: string,
    containerName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelContainerInspectModelsModelIdInspectContainerNameGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModelContainerInspectModelsModelIdInspectContainerNameGet>>,
          TError,
          Awaited<ReturnType<typeof getModelContainerInspectModelsModelIdInspectContainerNameGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModelContainerInspectModelsModelIdInspectContainerNameGet<TData = Awaited<ReturnType<typeof getModelContainerInspectModelsModelIdInspectContainerNameGet>>, TError = HTTPValidationError>(
 modelId: string,
    containerName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelContainerInspectModelsModelIdInspectContainerNameGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Model Container Inspect
 */

export function useGetModelContainerInspectModelsModelIdInspectContainerNameGet<TData = Awaited<ReturnType<typeof getModelContainerInspectModelsModelIdInspectContainerNameGet>>, TError = HTTPValidationError>(
 modelId: string,
    containerName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelContainerInspectModelsModelIdInspectContainerNameGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModelContainerInspectModelsModelIdInspectContainerNameGetQueryOptions(modelId,containerName,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * èŽ·å–æ‰€æœ‰æ¨¡åž‹å®¹å™¨è¯¦ç»†ä¿¡æ¯
 * @summary Get Model All Container Inspect
 */
export const getModelAllContainerInspectModelsModelIdInspectGet = (
    modelId: string,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<ApiResponseGetModelAllContainerInspectResponse>(
      {url: `/models/${modelId}/inspect`, method: 'GET', signal
    },
      );
    }
  

export const getGetModelAllContainerInspectModelsModelIdInspectGetQueryKey = (modelId: string,) => {
    return [`/models/${modelId}/inspect`] as const;
    }

    
export const getGetModelAllContainerInspectModelsModelIdInspectGetQueryOptions = <TData = Awaited<ReturnType<typeof getModelAllContainerInspectModelsModelIdInspectGet>>, TError = HTTPValidationError>(modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelAllContainerInspectModelsModelIdInspectGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModelAllContainerInspectModelsModelIdInspectGetQueryKey(modelId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModelAllContainerInspectModelsModelIdInspectGet>>> = ({ signal }) => getModelAllContainerInspectModelsModelIdInspectGet(modelId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(modelId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getModelAllContainerInspectModelsModelIdInspectGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModelAllContainerInspectModelsModelIdInspectGetQueryResult = NonNullable<Awaited<ReturnType<typeof getModelAllContainerInspectModelsModelIdInspectGet>>>
export type GetModelAllContainerInspectModelsModelIdInspectGetQueryError = HTTPValidationError


export function useGetModelAllContainerInspectModelsModelIdInspectGet<TData = Awaited<ReturnType<typeof getModelAllContainerInspectModelsModelIdInspectGet>>, TError = HTTPValidationError>(
 modelId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelAllContainerInspectModelsModelIdInspectGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModelAllContainerInspectModelsModelIdInspectGet>>,
          TError,
          Awaited<ReturnType<typeof getModelAllContainerInspectModelsModelIdInspectGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModelAllContainerInspectModelsModelIdInspectGet<TData = Awaited<ReturnType<typeof getModelAllContainerInspectModelsModelIdInspectGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelAllContainerInspectModelsModelIdInspectGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModelAllContainerInspectModelsModelIdInspectGet>>,
          TError,
          Awaited<ReturnType<typeof getModelAllContainerInspectModelsModelIdInspectGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModelAllContainerInspectModelsModelIdInspectGet<TData = Awaited<ReturnType<typeof getModelAllContainerInspectModelsModelIdInspectGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelAllContainerInspectModelsModelIdInspectGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Model All Container Inspect
 */

export function useGetModelAllContainerInspectModelsModelIdInspectGet<TData = Awaited<ReturnType<typeof getModelAllContainerInspectModelsModelIdInspectGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelAllContainerInspectModelsModelIdInspectGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModelAllContainerInspectModelsModelIdInspectGetQueryOptions(modelId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * èŽ·å–æ¨¡åž‹æ•°æ®æ–‡ä»¶æ ‘
 * @summary Get Model File Tree
 */
export const getModelFileTreeModelsModelIdFilesGet = (
    modelId: string,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<ApiResponseGetDataFileTreeResponse>(
      {url: `/models/${modelId}/files`, method: 'GET', signal
    },
      );
    }
  

export const getGetModelFileTreeModelsModelIdFilesGetQueryKey = (modelId: string,) => {
    return [`/models/${modelId}/files`] as const;
    }

    
export const getGetModelFileTreeModelsModelIdFilesGetQueryOptions = <TData = Awaited<ReturnType<typeof getModelFileTreeModelsModelIdFilesGet>>, TError = HTTPValidationError>(modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelFileTreeModelsModelIdFilesGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModelFileTreeModelsModelIdFilesGetQueryKey(modelId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModelFileTreeModelsModelIdFilesGet>>> = ({ signal }) => getModelFileTreeModelsModelIdFilesGet(modelId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(modelId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getModelFileTreeModelsModelIdFilesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModelFileTreeModelsModelIdFilesGetQueryResult = NonNullable<Awaited<ReturnType<typeof getModelFileTreeModelsModelIdFilesGet>>>
export type GetModelFileTreeModelsModelIdFilesGetQueryError = HTTPValidationError


export function useGetModelFileTreeModelsModelIdFilesGet<TData = Awaited<ReturnType<typeof getModelFileTreeModelsModelIdFilesGet>>, TError = HTTPValidationError>(
 modelId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelFileTreeModelsModelIdFilesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModelFileTreeModelsModelIdFilesGet>>,
          TError,
          Awaited<ReturnType<typeof getModelFileTreeModelsModelIdFilesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModelFileTreeModelsModelIdFilesGet<TData = Awaited<ReturnType<typeof getModelFileTreeModelsModelIdFilesGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelFileTreeModelsModelIdFilesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModelFileTreeModelsModelIdFilesGet>>,
          TError,
          Awaited<ReturnType<typeof getModelFileTreeModelsModelIdFilesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModelFileTreeModelsModelIdFilesGet<TData = Awaited<ReturnType<typeof getModelFileTreeModelsModelIdFilesGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelFileTreeModelsModelIdFilesGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Model File Tree
 */

export function useGetModelFileTreeModelsModelIdFilesGet<TData = Awaited<ReturnType<typeof getModelFileTreeModelsModelIdFilesGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelFileTreeModelsModelIdFilesGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModelFileTreeModelsModelIdFilesGetQueryOptions(modelId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * æ›´æ–°æ¨¡åž‹æ•°æ®æ–‡ä»¶å†…å®¹
 * @summary Update Model File Content
 */
export const updateModelFileContentModelsModelIdFilesPut = (
    modelId: string,
    updateDataFileRequest: UpdateDataFileRequest,
 ) => {
      
      
      return docker_manager_api<ApiResponse>(
      {url: `/models/${modelId}/files`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateDataFileRequest
    },
      );
    }
  


export const getUpdateModelFileContentModelsModelIdFilesPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateModelFileContentModelsModelIdFilesPut>>, TError,{modelId: string;data: UpdateDataFileRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateModelFileContentModelsModelIdFilesPut>>, TError,{modelId: string;data: UpdateDataFileRequest}, TContext> => {

const mutationKey = ['updateModelFileContentModelsModelIdFilesPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateModelFileContentModelsModelIdFilesPut>>, {modelId: string;data: UpdateDataFileRequest}> = (props) => {
          const {modelId,data} = props ?? {};

          return  updateModelFileContentModelsModelIdFilesPut(modelId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateModelFileContentModelsModelIdFilesPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateModelFileContentModelsModelIdFilesPut>>>
    export type UpdateModelFileContentModelsModelIdFilesPutMutationBody = UpdateDataFileRequest
    export type UpdateModelFileContentModelsModelIdFilesPutMutationError = HTTPValidationError

    /**
 * @summary Update Model File Content
 */
export const useUpdateModelFileContentModelsModelIdFilesPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateModelFileContentModelsModelIdFilesPut>>, TError,{modelId: string;data: UpdateDataFileRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateModelFileContentModelsModelIdFilesPut>>,
        TError,
        {modelId: string;data: UpdateDataFileRequest},
        TContext
      > => {

      const mutationOptions = getUpdateModelFileContentModelsModelIdFilesPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * åˆ›å»ºæ¨¡åž‹æ•°æ®æ–‡ä»¶
 * @summary Create Model File
 */
export const createModelFileModelsModelIdFilesPost = (
    modelId: string,
    createDataFileRequest: CreateDataFileRequest,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<ApiResponse>(
      {url: `/models/${modelId}/files`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createDataFileRequest, signal
    },
      );
    }
  


export const getCreateModelFileModelsModelIdFilesPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createModelFileModelsModelIdFilesPost>>, TError,{modelId: string;data: CreateDataFileRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createModelFileModelsModelIdFilesPost>>, TError,{modelId: string;data: CreateDataFileRequest}, TContext> => {

const mutationKey = ['createModelFileModelsModelIdFilesPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createModelFileModelsModelIdFilesPost>>, {modelId: string;data: CreateDataFileRequest}> = (props) => {
          const {modelId,data} = props ?? {};

          return  createModelFileModelsModelIdFilesPost(modelId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateModelFileModelsModelIdFilesPostMutationResult = NonNullable<Awaited<ReturnType<typeof createModelFileModelsModelIdFilesPost>>>
    export type CreateModelFileModelsModelIdFilesPostMutationBody = CreateDataFileRequest
    export type CreateModelFileModelsModelIdFilesPostMutationError = HTTPValidationError

    /**
 * @summary Create Model File
 */
export const useCreateModelFileModelsModelIdFilesPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createModelFileModelsModelIdFilesPost>>, TError,{modelId: string;data: CreateDataFileRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createModelFileModelsModelIdFilesPost>>,
        TError,
        {modelId: string;data: CreateDataFileRequest},
        TContext
      > => {

      const mutationOptions = getCreateModelFileModelsModelIdFilesPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * åˆ é™¤æ¨¡åž‹æ•°æ®æ–‡ä»¶æˆ–ç›®å½•
 * @summary Delete Model File
 */
export const deleteModelFileModelsModelIdFilesDelete = (
    modelId: string,
    deleteDataFileRequest: DeleteDataFileRequest,
 ) => {
      
      
      return docker_manager_api<ApiResponse>(
      {url: `/models/${modelId}/files`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: deleteDataFileRequest
    },
      );
    }
  


export const getDeleteModelFileModelsModelIdFilesDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteModelFileModelsModelIdFilesDelete>>, TError,{modelId: string;data: DeleteDataFileRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteModelFileModelsModelIdFilesDelete>>, TError,{modelId: string;data: DeleteDataFileRequest}, TContext> => {

const mutationKey = ['deleteModelFileModelsModelIdFilesDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteModelFileModelsModelIdFilesDelete>>, {modelId: string;data: DeleteDataFileRequest}> = (props) => {
          const {modelId,data} = props ?? {};

          return  deleteModelFileModelsModelIdFilesDelete(modelId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteModelFileModelsModelIdFilesDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteModelFileModelsModelIdFilesDelete>>>
    export type DeleteModelFileModelsModelIdFilesDeleteMutationBody = DeleteDataFileRequest
    export type DeleteModelFileModelsModelIdFilesDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Model File
 */
export const useDeleteModelFileModelsModelIdFilesDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteModelFileModelsModelIdFilesDelete>>, TError,{modelId: string;data: DeleteDataFileRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteModelFileModelsModelIdFilesDelete>>,
        TError,
        {modelId: string;data: DeleteDataFileRequest},
        TContext
      > => {

      const mutationOptions = getDeleteModelFileModelsModelIdFilesDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * èŽ·å–æ¨¡åž‹æ•°æ®æ–‡ä»¶å†…å®¹
 * @summary Get Model File Content
 */
export const getModelFileContentModelsModelIdFilesContentPost = (
    modelId: string,
    getDataFileContentRequest: GetDataFileContentRequest,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<ApiResponseGetDataFileContentResponse>(
      {url: `/models/${modelId}/files/content`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: getDataFileContentRequest, signal
    },
      );
    }
  


export const getGetModelFileContentModelsModelIdFilesContentPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getModelFileContentModelsModelIdFilesContentPost>>, TError,{modelId: string;data: GetDataFileContentRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof getModelFileContentModelsModelIdFilesContentPost>>, TError,{modelId: string;data: GetDataFileContentRequest}, TContext> => {

const mutationKey = ['getModelFileContentModelsModelIdFilesContentPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getModelFileContentModelsModelIdFilesContentPost>>, {modelId: string;data: GetDataFileContentRequest}> = (props) => {
          const {modelId,data} = props ?? {};

          return  getModelFileContentModelsModelIdFilesContentPost(modelId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetModelFileContentModelsModelIdFilesContentPostMutationResult = NonNullable<Awaited<ReturnType<typeof getModelFileContentModelsModelIdFilesContentPost>>>
    export type GetModelFileContentModelsModelIdFilesContentPostMutationBody = GetDataFileContentRequest
    export type GetModelFileContentModelsModelIdFilesContentPostMutationError = HTTPValidationError

    /**
 * @summary Get Model File Content
 */
export const useGetModelFileContentModelsModelIdFilesContentPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getModelFileContentModelsModelIdFilesContentPost>>, TError,{modelId: string;data: GetDataFileContentRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof getModelFileContentModelsModelIdFilesContentPost>>,
        TError,
        {modelId: string;data: GetDataFileContentRequest},
        TContext
      > => {

      const mutationOptions = getGetModelFileContentModelsModelIdFilesContentPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * åˆ›å»ºæ¨¡åž‹æ•°æ®ç›®å½•
 * @summary Create Model Directory
 */
export const createModelDirectoryModelsModelIdFilesDirectoriesPost = (
    modelId: string,
    createDataDirectoryRequest: CreateDataDirectoryRequest,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<ApiResponse>(
      {url: `/models/${modelId}/files/directories`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createDataDirectoryRequest, signal
    },
      );
    }
  


export const getCreateModelDirectoryModelsModelIdFilesDirectoriesPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createModelDirectoryModelsModelIdFilesDirectoriesPost>>, TError,{modelId: string;data: CreateDataDirectoryRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createModelDirectoryModelsModelIdFilesDirectoriesPost>>, TError,{modelId: string;data: CreateDataDirectoryRequest}, TContext> => {

const mutationKey = ['createModelDirectoryModelsModelIdFilesDirectoriesPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createModelDirectoryModelsModelIdFilesDirectoriesPost>>, {modelId: string;data: CreateDataDirectoryRequest}> = (props) => {
          const {modelId,data} = props ?? {};

          return  createModelDirectoryModelsModelIdFilesDirectoriesPost(modelId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateModelDirectoryModelsModelIdFilesDirectoriesPostMutationResult = NonNullable<Awaited<ReturnType<typeof createModelDirectoryModelsModelIdFilesDirectoriesPost>>>
    export type CreateModelDirectoryModelsModelIdFilesDirectoriesPostMutationBody = CreateDataDirectoryRequest
    export type CreateModelDirectoryModelsModelIdFilesDirectoriesPostMutationError = HTTPValidationError

    /**
 * @summary Create Model Directory
 */
export const useCreateModelDirectoryModelsModelIdFilesDirectoriesPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createModelDirectoryModelsModelIdFilesDirectoriesPost>>, TError,{modelId: string;data: CreateDataDirectoryRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createModelDirectoryModelsModelIdFilesDirectoriesPost>>,
        TError,
        {modelId: string;data: CreateDataDirectoryRequest},
        TContext
      > => {

      const mutationOptions = getCreateModelDirectoryModelsModelIdFilesDirectoriesPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ä¸Šä¼ æ–‡ä»¶åˆ°æ¨¡åž‹ç›®å½•
 * @summary Upload Model File
 */
export const uploadModelFileModelsModelIdFilesUploadPost = (
    modelId: string,
    bodyUploadModelFileModelsModelIdFilesUploadPost: BodyUploadModelFileModelsModelIdFilesUploadPost,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`file`, bodyUploadModelFileModelsModelIdFilesUploadPost.file)
formData.append(`file_path`, bodyUploadModelFileModelsModelIdFilesUploadPost.file_path)

      return docker_manager_api<ApiResponse>(
      {url: `/models/${modelId}/files/upload`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getUploadModelFileModelsModelIdFilesUploadPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadModelFileModelsModelIdFilesUploadPost>>, TError,{modelId: string;data: BodyUploadModelFileModelsModelIdFilesUploadPost}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof uploadModelFileModelsModelIdFilesUploadPost>>, TError,{modelId: string;data: BodyUploadModelFileModelsModelIdFilesUploadPost}, TContext> => {

const mutationKey = ['uploadModelFileModelsModelIdFilesUploadPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadModelFileModelsModelIdFilesUploadPost>>, {modelId: string;data: BodyUploadModelFileModelsModelIdFilesUploadPost}> = (props) => {
          const {modelId,data} = props ?? {};

          return  uploadModelFileModelsModelIdFilesUploadPost(modelId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UploadModelFileModelsModelIdFilesUploadPostMutationResult = NonNullable<Awaited<ReturnType<typeof uploadModelFileModelsModelIdFilesUploadPost>>>
    export type UploadModelFileModelsModelIdFilesUploadPostMutationBody = BodyUploadModelFileModelsModelIdFilesUploadPost
    export type UploadModelFileModelsModelIdFilesUploadPostMutationError = HTTPValidationError

    /**
 * @summary Upload Model File
 */
export const useUploadModelFileModelsModelIdFilesUploadPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadModelFileModelsModelIdFilesUploadPost>>, TError,{modelId: string;data: BodyUploadModelFileModelsModelIdFilesUploadPost}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof uploadModelFileModelsModelIdFilesUploadPost>>,
        TError,
        {modelId: string;data: BodyUploadModelFileModelsModelIdFilesUploadPost},
        TContext
      > => {

      const mutationOptions = getUploadModelFileModelsModelIdFilesUploadPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * èŽ·å–æŒ‡å®šå®¹å™¨çš„æœ€æ–°æ•°æ®åŒ…æ–‡ä»¶ä¿¡æ¯
 * @summary Get Container Packet File
 */
export const getContainerPacketFileModelsModelIdContainersContainerNamePacketGet = (
    modelId: string,
    containerName: string,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<ApiResponsePacketFileResponse>(
      {url: `/models/${modelId}/containers/${containerName}/packet`, method: 'GET', signal
    },
      );
    }
  

export const getGetContainerPacketFileModelsModelIdContainersContainerNamePacketGetQueryKey = (modelId: string,
    containerName: string,) => {
    return [`/models/${modelId}/containers/${containerName}/packet`] as const;
    }

    
export const getGetContainerPacketFileModelsModelIdContainersContainerNamePacketGetQueryOptions = <TData = Awaited<ReturnType<typeof getContainerPacketFileModelsModelIdContainersContainerNamePacketGet>>, TError = HTTPValidationError>(modelId: string,
    containerName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getContainerPacketFileModelsModelIdContainersContainerNamePacketGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetContainerPacketFileModelsModelIdContainersContainerNamePacketGetQueryKey(modelId,containerName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getContainerPacketFileModelsModelIdContainersContainerNamePacketGet>>> = ({ signal }) => getContainerPacketFileModelsModelIdContainersContainerNamePacketGet(modelId,containerName, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(modelId && containerName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getContainerPacketFileModelsModelIdContainersContainerNamePacketGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetContainerPacketFileModelsModelIdContainersContainerNamePacketGetQueryResult = NonNullable<Awaited<ReturnType<typeof getContainerPacketFileModelsModelIdContainersContainerNamePacketGet>>>
export type GetContainerPacketFileModelsModelIdContainersContainerNamePacketGetQueryError = HTTPValidationError


export function useGetContainerPacketFileModelsModelIdContainersContainerNamePacketGet<TData = Awaited<ReturnType<typeof getContainerPacketFileModelsModelIdContainersContainerNamePacketGet>>, TError = HTTPValidationError>(
 modelId: string,
    containerName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getContainerPacketFileModelsModelIdContainersContainerNamePacketGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getContainerPacketFileModelsModelIdContainersContainerNamePacketGet>>,
          TError,
          Awaited<ReturnType<typeof getContainerPacketFileModelsModelIdContainersContainerNamePacketGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetContainerPacketFileModelsModelIdContainersContainerNamePacketGet<TData = Awaited<ReturnType<typeof getContainerPacketFileModelsModelIdContainersContainerNamePacketGet>>, TError = HTTPValidationError>(
 modelId: string,
    containerName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getContainerPacketFileModelsModelIdContainersContainerNamePacketGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getContainerPacketFileModelsModelIdContainersContainerNamePacketGet>>,
          TError,
          Awaited<ReturnType<typeof getContainerPacketFileModelsModelIdContainersContainerNamePacketGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetContainerPacketFileModelsModelIdContainersContainerNamePacketGet<TData = Awaited<ReturnType<typeof getContainerPacketFileModelsModelIdContainersContainerNamePacketGet>>, TError = HTTPValidationError>(
 modelId: string,
    containerName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getContainerPacketFileModelsModelIdContainersContainerNamePacketGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Container Packet File
 */

export function useGetContainerPacketFileModelsModelIdContainersContainerNamePacketGet<TData = Awaited<ReturnType<typeof getContainerPacketFileModelsModelIdContainersContainerNamePacketGet>>, TError = HTTPValidationError>(
 modelId: string,
    containerName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getContainerPacketFileModelsModelIdContainersContainerNamePacketGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetContainerPacketFileModelsModelIdContainersContainerNamePacketGetQueryOptions(modelId,containerName,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * èŽ·å–æŒ‡å®šæ¨¡åž‹æ‰€æœ‰å®¹å™¨çš„æ•°æ®åŒ…æ–‡ä»¶ä¿¡æ¯
 * @summary Get All Packet Files
 */
export const getAllPacketFilesModelsModelIdPacketsGet = (
    modelId: string,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<ApiResponseAllPacketFilesResponse>(
      {url: `/models/${modelId}/packets`, method: 'GET', signal
    },
      );
    }
  

export const getGetAllPacketFilesModelsModelIdPacketsGetQueryKey = (modelId: string,) => {
    return [`/models/${modelId}/packets`] as const;
    }

    
export const getGetAllPacketFilesModelsModelIdPacketsGetQueryOptions = <TData = Awaited<ReturnType<typeof getAllPacketFilesModelsModelIdPacketsGet>>, TError = HTTPValidationError>(modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllPacketFilesModelsModelIdPacketsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllPacketFilesModelsModelIdPacketsGetQueryKey(modelId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllPacketFilesModelsModelIdPacketsGet>>> = ({ signal }) => getAllPacketFilesModelsModelIdPacketsGet(modelId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(modelId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllPacketFilesModelsModelIdPacketsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllPacketFilesModelsModelIdPacketsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getAllPacketFilesModelsModelIdPacketsGet>>>
export type GetAllPacketFilesModelsModelIdPacketsGetQueryError = HTTPValidationError


export function useGetAllPacketFilesModelsModelIdPacketsGet<TData = Awaited<ReturnType<typeof getAllPacketFilesModelsModelIdPacketsGet>>, TError = HTTPValidationError>(
 modelId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllPacketFilesModelsModelIdPacketsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllPacketFilesModelsModelIdPacketsGet>>,
          TError,
          Awaited<ReturnType<typeof getAllPacketFilesModelsModelIdPacketsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllPacketFilesModelsModelIdPacketsGet<TData = Awaited<ReturnType<typeof getAllPacketFilesModelsModelIdPacketsGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllPacketFilesModelsModelIdPacketsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllPacketFilesModelsModelIdPacketsGet>>,
          TError,
          Awaited<ReturnType<typeof getAllPacketFilesModelsModelIdPacketsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllPacketFilesModelsModelIdPacketsGet<TData = Awaited<ReturnType<typeof getAllPacketFilesModelsModelIdPacketsGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllPacketFilesModelsModelIdPacketsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get All Packet Files
 */

export function useGetAllPacketFilesModelsModelIdPacketsGet<TData = Awaited<ReturnType<typeof getAllPacketFilesModelsModelIdPacketsGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllPacketFilesModelsModelIdPacketsGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllPacketFilesModelsModelIdPacketsGetQueryOptions(modelId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ä¸‹è½½æŒ‡å®šå®¹å™¨çš„æ•°æ®åŒ…æ–‡ä»¶
 * @summary Download Container Packet File
 */
export const downloadContainerPacketFileModelsModelIdContainersContainerNamePacketDownloadGet = (
    modelId: string,
    containerName: string,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<unknown>(
      {url: `/models/${modelId}/containers/${containerName}/packet/download`, method: 'GET', signal
    },
      );
    }
  

export const getDownloadContainerPacketFileModelsModelIdContainersContainerNamePacketDownloadGetQueryKey = (modelId: string,
    containerName: string,) => {
    return [`/models/${modelId}/containers/${containerName}/packet/download`] as const;
    }

    
export const getDownloadContainerPacketFileModelsModelIdContainersContainerNamePacketDownloadGetQueryOptions = <TData = Awaited<ReturnType<typeof downloadContainerPacketFileModelsModelIdContainersContainerNamePacketDownloadGet>>, TError = HTTPValidationError>(modelId: string,
    containerName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadContainerPacketFileModelsModelIdContainersContainerNamePacketDownloadGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDownloadContainerPacketFileModelsModelIdContainersContainerNamePacketDownloadGetQueryKey(modelId,containerName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof downloadContainerPacketFileModelsModelIdContainersContainerNamePacketDownloadGet>>> = ({ signal }) => downloadContainerPacketFileModelsModelIdContainersContainerNamePacketDownloadGet(modelId,containerName, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(modelId && containerName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof downloadContainerPacketFileModelsModelIdContainersContainerNamePacketDownloadGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DownloadContainerPacketFileModelsModelIdContainersContainerNamePacketDownloadGetQueryResult = NonNullable<Awaited<ReturnType<typeof downloadContainerPacketFileModelsModelIdContainersContainerNamePacketDownloadGet>>>
export type DownloadContainerPacketFileModelsModelIdContainersContainerNamePacketDownloadGetQueryError = HTTPValidationError


export function useDownloadContainerPacketFileModelsModelIdContainersContainerNamePacketDownloadGet<TData = Awaited<ReturnType<typeof downloadContainerPacketFileModelsModelIdContainersContainerNamePacketDownloadGet>>, TError = HTTPValidationError>(
 modelId: string,
    containerName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadContainerPacketFileModelsModelIdContainersContainerNamePacketDownloadGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof downloadContainerPacketFileModelsModelIdContainersContainerNamePacketDownloadGet>>,
          TError,
          Awaited<ReturnType<typeof downloadContainerPacketFileModelsModelIdContainersContainerNamePacketDownloadGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDownloadContainerPacketFileModelsModelIdContainersContainerNamePacketDownloadGet<TData = Awaited<ReturnType<typeof downloadContainerPacketFileModelsModelIdContainersContainerNamePacketDownloadGet>>, TError = HTTPValidationError>(
 modelId: string,
    containerName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadContainerPacketFileModelsModelIdContainersContainerNamePacketDownloadGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof downloadContainerPacketFileModelsModelIdContainersContainerNamePacketDownloadGet>>,
          TError,
          Awaited<ReturnType<typeof downloadContainerPacketFileModelsModelIdContainersContainerNamePacketDownloadGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDownloadContainerPacketFileModelsModelIdContainersContainerNamePacketDownloadGet<TData = Awaited<ReturnType<typeof downloadContainerPacketFileModelsModelIdContainersContainerNamePacketDownloadGet>>, TError = HTTPValidationError>(
 modelId: string,
    containerName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadContainerPacketFileModelsModelIdContainersContainerNamePacketDownloadGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Download Container Packet File
 */

export function useDownloadContainerPacketFileModelsModelIdContainersContainerNamePacketDownloadGet<TData = Awaited<ReturnType<typeof downloadContainerPacketFileModelsModelIdContainersContainerNamePacketDownloadGet>>, TError = HTTPValidationError>(
 modelId: string,
    containerName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadContainerPacketFileModelsModelIdContainersContainerNamePacketDownloadGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDownloadContainerPacketFileModelsModelIdContainersContainerNamePacketDownloadGetQueryOptions(modelId,containerName,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * èŽ·å–DinDå†…æ‰€æœ‰å®¹å™¨ï¼ŒåŒ…æ‹¬å…³é—­çš„
 * @summary Get Model Dind Containers
 */
export const getModelDindContainersModelsModelIdDindGet = (
    modelId: string,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<ApiResponseDict>(
      {url: `/models/${modelId}/dind`, method: 'GET', signal
    },
      );
    }
  

export const getGetModelDindContainersModelsModelIdDindGetQueryKey = (modelId: string,) => {
    return [`/models/${modelId}/dind`] as const;
    }

    
export const getGetModelDindContainersModelsModelIdDindGetQueryOptions = <TData = Awaited<ReturnType<typeof getModelDindContainersModelsModelIdDindGet>>, TError = HTTPValidationError>(modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelDindContainersModelsModelIdDindGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetModelDindContainersModelsModelIdDindGetQueryKey(modelId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getModelDindContainersModelsModelIdDindGet>>> = ({ signal }) => getModelDindContainersModelsModelIdDindGet(modelId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(modelId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getModelDindContainersModelsModelIdDindGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetModelDindContainersModelsModelIdDindGetQueryResult = NonNullable<Awaited<ReturnType<typeof getModelDindContainersModelsModelIdDindGet>>>
export type GetModelDindContainersModelsModelIdDindGetQueryError = HTTPValidationError


export function useGetModelDindContainersModelsModelIdDindGet<TData = Awaited<ReturnType<typeof getModelDindContainersModelsModelIdDindGet>>, TError = HTTPValidationError>(
 modelId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelDindContainersModelsModelIdDindGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModelDindContainersModelsModelIdDindGet>>,
          TError,
          Awaited<ReturnType<typeof getModelDindContainersModelsModelIdDindGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModelDindContainersModelsModelIdDindGet<TData = Awaited<ReturnType<typeof getModelDindContainersModelsModelIdDindGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelDindContainersModelsModelIdDindGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModelDindContainersModelsModelIdDindGet>>,
          TError,
          Awaited<ReturnType<typeof getModelDindContainersModelsModelIdDindGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetModelDindContainersModelsModelIdDindGet<TData = Awaited<ReturnType<typeof getModelDindContainersModelsModelIdDindGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelDindContainersModelsModelIdDindGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Model Dind Containers
 */

export function useGetModelDindContainersModelsModelIdDindGet<TData = Awaited<ReturnType<typeof getModelDindContainersModelsModelIdDindGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getModelDindContainersModelsModelIdDindGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetModelDindContainersModelsModelIdDindGetQueryOptions(modelId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * èŽ·å–DinDå†…æ‰€æœ‰å®¹å™¨çš„è¯¦ç»†inspectä¿¡æ¯
 * @summary Get Dind All Container Inspect
 */
export const getDindAllContainerInspectModelsModelIdDindInspectGet = (
    modelId: string,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<ApiResponseDict>(
      {url: `/models/${modelId}/dind/inspect`, method: 'GET', signal
    },
      );
    }
  

export const getGetDindAllContainerInspectModelsModelIdDindInspectGetQueryKey = (modelId: string,) => {
    return [`/models/${modelId}/dind/inspect`] as const;
    }

    
export const getGetDindAllContainerInspectModelsModelIdDindInspectGetQueryOptions = <TData = Awaited<ReturnType<typeof getDindAllContainerInspectModelsModelIdDindInspectGet>>, TError = HTTPValidationError>(modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDindAllContainerInspectModelsModelIdDindInspectGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDindAllContainerInspectModelsModelIdDindInspectGetQueryKey(modelId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDindAllContainerInspectModelsModelIdDindInspectGet>>> = ({ signal }) => getDindAllContainerInspectModelsModelIdDindInspectGet(modelId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(modelId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDindAllContainerInspectModelsModelIdDindInspectGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDindAllContainerInspectModelsModelIdDindInspectGetQueryResult = NonNullable<Awaited<ReturnType<typeof getDindAllContainerInspectModelsModelIdDindInspectGet>>>
export type GetDindAllContainerInspectModelsModelIdDindInspectGetQueryError = HTTPValidationError


export function useGetDindAllContainerInspectModelsModelIdDindInspectGet<TData = Awaited<ReturnType<typeof getDindAllContainerInspectModelsModelIdDindInspectGet>>, TError = HTTPValidationError>(
 modelId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDindAllContainerInspectModelsModelIdDindInspectGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDindAllContainerInspectModelsModelIdDindInspectGet>>,
          TError,
          Awaited<ReturnType<typeof getDindAllContainerInspectModelsModelIdDindInspectGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDindAllContainerInspectModelsModelIdDindInspectGet<TData = Awaited<ReturnType<typeof getDindAllContainerInspectModelsModelIdDindInspectGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDindAllContainerInspectModelsModelIdDindInspectGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDindAllContainerInspectModelsModelIdDindInspectGet>>,
          TError,
          Awaited<ReturnType<typeof getDindAllContainerInspectModelsModelIdDindInspectGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDindAllContainerInspectModelsModelIdDindInspectGet<TData = Awaited<ReturnType<typeof getDindAllContainerInspectModelsModelIdDindInspectGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDindAllContainerInspectModelsModelIdDindInspectGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Dind All Container Inspect
 */

export function useGetDindAllContainerInspectModelsModelIdDindInspectGet<TData = Awaited<ReturnType<typeof getDindAllContainerInspectModelsModelIdDindInspectGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDindAllContainerInspectModelsModelIdDindInspectGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDindAllContainerInspectModelsModelIdDindInspectGetQueryOptions(modelId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * èŽ·å–DinDå†…æŒ‡å®šå®¹å™¨çš„è¯¦ç»†inspectä¿¡æ¯
 * @summary Get Dind Container Inspect
 */
export const getDindContainerInspectModelsModelIdDindInspectContainerNameGet = (
    modelId: string,
    containerName: string,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<ApiResponseDict>(
      {url: `/models/${modelId}/dind/inspect/${containerName}`, method: 'GET', signal
    },
      );
    }
  

export const getGetDindContainerInspectModelsModelIdDindInspectContainerNameGetQueryKey = (modelId: string,
    containerName: string,) => {
    return [`/models/${modelId}/dind/inspect/${containerName}`] as const;
    }

    
export const getGetDindContainerInspectModelsModelIdDindInspectContainerNameGetQueryOptions = <TData = Awaited<ReturnType<typeof getDindContainerInspectModelsModelIdDindInspectContainerNameGet>>, TError = HTTPValidationError>(modelId: string,
    containerName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDindContainerInspectModelsModelIdDindInspectContainerNameGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDindContainerInspectModelsModelIdDindInspectContainerNameGetQueryKey(modelId,containerName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDindContainerInspectModelsModelIdDindInspectContainerNameGet>>> = ({ signal }) => getDindContainerInspectModelsModelIdDindInspectContainerNameGet(modelId,containerName, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(modelId && containerName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDindContainerInspectModelsModelIdDindInspectContainerNameGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDindContainerInspectModelsModelIdDindInspectContainerNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof getDindContainerInspectModelsModelIdDindInspectContainerNameGet>>>
export type GetDindContainerInspectModelsModelIdDindInspectContainerNameGetQueryError = HTTPValidationError


export function useGetDindContainerInspectModelsModelIdDindInspectContainerNameGet<TData = Awaited<ReturnType<typeof getDindContainerInspectModelsModelIdDindInspectContainerNameGet>>, TError = HTTPValidationError>(
 modelId: string,
    containerName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDindContainerInspectModelsModelIdDindInspectContainerNameGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDindContainerInspectModelsModelIdDindInspectContainerNameGet>>,
          TError,
          Awaited<ReturnType<typeof getDindContainerInspectModelsModelIdDindInspectContainerNameGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDindContainerInspectModelsModelIdDindInspectContainerNameGet<TData = Awaited<ReturnType<typeof getDindContainerInspectModelsModelIdDindInspectContainerNameGet>>, TError = HTTPValidationError>(
 modelId: string,
    containerName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDindContainerInspectModelsModelIdDindInspectContainerNameGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDindContainerInspectModelsModelIdDindInspectContainerNameGet>>,
          TError,
          Awaited<ReturnType<typeof getDindContainerInspectModelsModelIdDindInspectContainerNameGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDindContainerInspectModelsModelIdDindInspectContainerNameGet<TData = Awaited<ReturnType<typeof getDindContainerInspectModelsModelIdDindInspectContainerNameGet>>, TError = HTTPValidationError>(
 modelId: string,
    containerName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDindContainerInspectModelsModelIdDindInspectContainerNameGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Dind Container Inspect
 */

export function useGetDindContainerInspectModelsModelIdDindInspectContainerNameGet<TData = Awaited<ReturnType<typeof getDindContainerInspectModelsModelIdDindInspectContainerNameGet>>, TError = HTTPValidationError>(
 modelId: string,
    containerName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDindContainerInspectModelsModelIdDindInspectContainerNameGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDindContainerInspectModelsModelIdDindInspectContainerNameGetQueryOptions(modelId,containerName,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * èŽ·å–DinDæ•°æ®åŒ…ä¿¡æ¯
 * @summary Get Dind Packet Files
 */
export const getDindPacketFilesModelsModelIdDindPacketsGet = (
    modelId: string,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<ApiResponseDict>(
      {url: `/models/${modelId}/dind/packets`, method: 'GET', signal
    },
      );
    }
  

export const getGetDindPacketFilesModelsModelIdDindPacketsGetQueryKey = (modelId: string,) => {
    return [`/models/${modelId}/dind/packets`] as const;
    }

    
export const getGetDindPacketFilesModelsModelIdDindPacketsGetQueryOptions = <TData = Awaited<ReturnType<typeof getDindPacketFilesModelsModelIdDindPacketsGet>>, TError = HTTPValidationError>(modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDindPacketFilesModelsModelIdDindPacketsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDindPacketFilesModelsModelIdDindPacketsGetQueryKey(modelId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDindPacketFilesModelsModelIdDindPacketsGet>>> = ({ signal }) => getDindPacketFilesModelsModelIdDindPacketsGet(modelId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(modelId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDindPacketFilesModelsModelIdDindPacketsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDindPacketFilesModelsModelIdDindPacketsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getDindPacketFilesModelsModelIdDindPacketsGet>>>
export type GetDindPacketFilesModelsModelIdDindPacketsGetQueryError = HTTPValidationError


export function useGetDindPacketFilesModelsModelIdDindPacketsGet<TData = Awaited<ReturnType<typeof getDindPacketFilesModelsModelIdDindPacketsGet>>, TError = HTTPValidationError>(
 modelId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDindPacketFilesModelsModelIdDindPacketsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDindPacketFilesModelsModelIdDindPacketsGet>>,
          TError,
          Awaited<ReturnType<typeof getDindPacketFilesModelsModelIdDindPacketsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDindPacketFilesModelsModelIdDindPacketsGet<TData = Awaited<ReturnType<typeof getDindPacketFilesModelsModelIdDindPacketsGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDindPacketFilesModelsModelIdDindPacketsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDindPacketFilesModelsModelIdDindPacketsGet>>,
          TError,
          Awaited<ReturnType<typeof getDindPacketFilesModelsModelIdDindPacketsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDindPacketFilesModelsModelIdDindPacketsGet<TData = Awaited<ReturnType<typeof getDindPacketFilesModelsModelIdDindPacketsGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDindPacketFilesModelsModelIdDindPacketsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Dind Packet Files
 */

export function useGetDindPacketFilesModelsModelIdDindPacketsGet<TData = Awaited<ReturnType<typeof getDindPacketFilesModelsModelIdDindPacketsGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDindPacketFilesModelsModelIdDindPacketsGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDindPacketFilesModelsModelIdDindPacketsGetQueryOptions(modelId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ä¸‹è½½æ•°æ®åŒ…
 * @summary Download Dind Packet File Direct
 */
export const downloadDindPacketFileDirectModelsModelIdDindPacketsContainerNameDownloadGet = (
    modelId: string,
    containerName: string,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<unknown>(
      {url: `/models/${modelId}/dind/packets/${containerName}/download`, method: 'GET', signal
    },
      );
    }
  

export const getDownloadDindPacketFileDirectModelsModelIdDindPacketsContainerNameDownloadGetQueryKey = (modelId: string,
    containerName: string,) => {
    return [`/models/${modelId}/dind/packets/${containerName}/download`] as const;
    }

    
export const getDownloadDindPacketFileDirectModelsModelIdDindPacketsContainerNameDownloadGetQueryOptions = <TData = Awaited<ReturnType<typeof downloadDindPacketFileDirectModelsModelIdDindPacketsContainerNameDownloadGet>>, TError = HTTPValidationError>(modelId: string,
    containerName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadDindPacketFileDirectModelsModelIdDindPacketsContainerNameDownloadGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDownloadDindPacketFileDirectModelsModelIdDindPacketsContainerNameDownloadGetQueryKey(modelId,containerName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof downloadDindPacketFileDirectModelsModelIdDindPacketsContainerNameDownloadGet>>> = ({ signal }) => downloadDindPacketFileDirectModelsModelIdDindPacketsContainerNameDownloadGet(modelId,containerName, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(modelId && containerName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof downloadDindPacketFileDirectModelsModelIdDindPacketsContainerNameDownloadGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DownloadDindPacketFileDirectModelsModelIdDindPacketsContainerNameDownloadGetQueryResult = NonNullable<Awaited<ReturnType<typeof downloadDindPacketFileDirectModelsModelIdDindPacketsContainerNameDownloadGet>>>
export type DownloadDindPacketFileDirectModelsModelIdDindPacketsContainerNameDownloadGetQueryError = HTTPValidationError


export function useDownloadDindPacketFileDirectModelsModelIdDindPacketsContainerNameDownloadGet<TData = Awaited<ReturnType<typeof downloadDindPacketFileDirectModelsModelIdDindPacketsContainerNameDownloadGet>>, TError = HTTPValidationError>(
 modelId: string,
    containerName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadDindPacketFileDirectModelsModelIdDindPacketsContainerNameDownloadGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof downloadDindPacketFileDirectModelsModelIdDindPacketsContainerNameDownloadGet>>,
          TError,
          Awaited<ReturnType<typeof downloadDindPacketFileDirectModelsModelIdDindPacketsContainerNameDownloadGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDownloadDindPacketFileDirectModelsModelIdDindPacketsContainerNameDownloadGet<TData = Awaited<ReturnType<typeof downloadDindPacketFileDirectModelsModelIdDindPacketsContainerNameDownloadGet>>, TError = HTTPValidationError>(
 modelId: string,
    containerName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadDindPacketFileDirectModelsModelIdDindPacketsContainerNameDownloadGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof downloadDindPacketFileDirectModelsModelIdDindPacketsContainerNameDownloadGet>>,
          TError,
          Awaited<ReturnType<typeof downloadDindPacketFileDirectModelsModelIdDindPacketsContainerNameDownloadGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDownloadDindPacketFileDirectModelsModelIdDindPacketsContainerNameDownloadGet<TData = Awaited<ReturnType<typeof downloadDindPacketFileDirectModelsModelIdDindPacketsContainerNameDownloadGet>>, TError = HTTPValidationError>(
 modelId: string,
    containerName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadDindPacketFileDirectModelsModelIdDindPacketsContainerNameDownloadGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Download Dind Packet File Direct
 */

export function useDownloadDindPacketFileDirectModelsModelIdDindPacketsContainerNameDownloadGet<TData = Awaited<ReturnType<typeof downloadDindPacketFileDirectModelsModelIdDindPacketsContainerNameDownloadGet>>, TError = HTTPValidationError>(
 modelId: string,
    containerName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadDindPacketFileDirectModelsModelIdDindPacketsContainerNameDownloadGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDownloadDindPacketFileDirectModelsModelIdDindPacketsContainerNameDownloadGetQueryOptions(modelId,containerName,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * èŽ·å–æŒ‡å®šå®¹å™¨çš„DinDæ•°æ®åŒ…æ–‡ä»¶è·¯å¾„ï¼ˆæ— éœ€ä¸‹è½½ï¼‰
 * @summary Get Dind Packet File Info
 */
export const getDindPacketFileInfoModelsModelIdDindPacketsContainerNameDownloadPost = (
    modelId: string,
    containerName: string,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<unknown>(
      {url: `/models/${modelId}/dind/packets/${containerName}/download`, method: 'POST', signal
    },
      );
    }
  


export const getGetDindPacketFileInfoModelsModelIdDindPacketsContainerNameDownloadPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getDindPacketFileInfoModelsModelIdDindPacketsContainerNameDownloadPost>>, TError,{modelId: string;containerName: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof getDindPacketFileInfoModelsModelIdDindPacketsContainerNameDownloadPost>>, TError,{modelId: string;containerName: string}, TContext> => {

const mutationKey = ['getDindPacketFileInfoModelsModelIdDindPacketsContainerNameDownloadPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getDindPacketFileInfoModelsModelIdDindPacketsContainerNameDownloadPost>>, {modelId: string;containerName: string}> = (props) => {
          const {modelId,containerName} = props ?? {};

          return  getDindPacketFileInfoModelsModelIdDindPacketsContainerNameDownloadPost(modelId,containerName,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetDindPacketFileInfoModelsModelIdDindPacketsContainerNameDownloadPostMutationResult = NonNullable<Awaited<ReturnType<typeof getDindPacketFileInfoModelsModelIdDindPacketsContainerNameDownloadPost>>>
    
    export type GetDindPacketFileInfoModelsModelIdDindPacketsContainerNameDownloadPostMutationError = HTTPValidationError

    /**
 * @summary Get Dind Packet File Info
 */
export const useGetDindPacketFileInfoModelsModelIdDindPacketsContainerNameDownloadPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getDindPacketFileInfoModelsModelIdDindPacketsContainerNameDownloadPost>>, TError,{modelId: string;containerName: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof getDindPacketFileInfoModelsModelIdDindPacketsContainerNameDownloadPost>>,
        TError,
        {modelId: string;containerName: string},
        TContext
      > => {

      const mutationOptions = getGetDindPacketFileInfoModelsModelIdDindPacketsContainerNameDownloadPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * æ ¹è·¯å¾„
 * @summary Root
 */
export const rootGet = (
    
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<ApiResponse>(
      {url: `/`, method: 'GET', signal
    },
      );
    }
  

export const getRootGetQueryKey = () => {
    return [`/`] as const;
    }

    
export const getRootGetQueryOptions = <TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRootGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof rootGet>>> = ({ signal }) => rootGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type RootGetQueryResult = NonNullable<Awaited<ReturnType<typeof rootGet>>>
export type RootGetQueryError = unknown


export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof rootGet>>,
          TError,
          Awaited<ReturnType<typeof rootGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof rootGet>>,
          TError,
          Awaited<ReturnType<typeof rootGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Root
 */

export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getRootGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * å¥åº·æ£€æŸ¥
 * @summary Health Check
 */
export const healthCheckHealthGet = (
    
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<ApiResponse>(
      {url: `/health`, method: 'GET', signal
    },
      );
    }
  

export const getHealthCheckHealthGetQueryKey = () => {
    return [`/health`] as const;
    }

    
export const getHealthCheckHealthGetQueryOptions = <TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthCheckHealthGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheckHealthGet>>> = ({ signal }) => healthCheckHealthGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthCheckHealthGetQueryResult = NonNullable<Awaited<ReturnType<typeof healthCheckHealthGet>>>
export type HealthCheckHealthGetQueryError = unknown


export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckHealthGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckHealthGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Health Check
 */

export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHealthCheckHealthGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * æµå¼èŽ·å–æ¨¡åž‹æž„å»ºæ—¥å¿—
 * @summary Stream Model Build Logs
 */
export const streamModelBuildLogsLogsStreamModelModelIdBuildGet = (
    modelId: string,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<unknown>(
      {url: `/logs/stream/model/${modelId}/build`, method: 'GET', signal
    },
      );
    }
  

export const getStreamModelBuildLogsLogsStreamModelModelIdBuildGetQueryKey = (modelId: string,) => {
    return [`/logs/stream/model/${modelId}/build`] as const;
    }

    
export const getStreamModelBuildLogsLogsStreamModelModelIdBuildGetQueryOptions = <TData = Awaited<ReturnType<typeof streamModelBuildLogsLogsStreamModelModelIdBuildGet>>, TError = HTTPValidationError>(modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamModelBuildLogsLogsStreamModelModelIdBuildGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStreamModelBuildLogsLogsStreamModelModelIdBuildGetQueryKey(modelId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof streamModelBuildLogsLogsStreamModelModelIdBuildGet>>> = ({ signal }) => streamModelBuildLogsLogsStreamModelModelIdBuildGet(modelId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(modelId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof streamModelBuildLogsLogsStreamModelModelIdBuildGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StreamModelBuildLogsLogsStreamModelModelIdBuildGetQueryResult = NonNullable<Awaited<ReturnType<typeof streamModelBuildLogsLogsStreamModelModelIdBuildGet>>>
export type StreamModelBuildLogsLogsStreamModelModelIdBuildGetQueryError = HTTPValidationError


export function useStreamModelBuildLogsLogsStreamModelModelIdBuildGet<TData = Awaited<ReturnType<typeof streamModelBuildLogsLogsStreamModelModelIdBuildGet>>, TError = HTTPValidationError>(
 modelId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamModelBuildLogsLogsStreamModelModelIdBuildGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamModelBuildLogsLogsStreamModelModelIdBuildGet>>,
          TError,
          Awaited<ReturnType<typeof streamModelBuildLogsLogsStreamModelModelIdBuildGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStreamModelBuildLogsLogsStreamModelModelIdBuildGet<TData = Awaited<ReturnType<typeof streamModelBuildLogsLogsStreamModelModelIdBuildGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamModelBuildLogsLogsStreamModelModelIdBuildGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamModelBuildLogsLogsStreamModelModelIdBuildGet>>,
          TError,
          Awaited<ReturnType<typeof streamModelBuildLogsLogsStreamModelModelIdBuildGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStreamModelBuildLogsLogsStreamModelModelIdBuildGet<TData = Awaited<ReturnType<typeof streamModelBuildLogsLogsStreamModelModelIdBuildGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamModelBuildLogsLogsStreamModelModelIdBuildGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Stream Model Build Logs
 */

export function useStreamModelBuildLogsLogsStreamModelModelIdBuildGet<TData = Awaited<ReturnType<typeof streamModelBuildLogsLogsStreamModelModelIdBuildGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamModelBuildLogsLogsStreamModelModelIdBuildGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStreamModelBuildLogsLogsStreamModelModelIdBuildGetQueryOptions(modelId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * æµå¼èŽ·å–æŒ‡å®šå®¹å™¨çš„æ—¥å¿—
 * @summary Stream Container Logs
 */
export const streamContainerLogsLogsStreamModelModelIdContainerContainerNameGet = (
    modelId: string,
    containerName: string,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<unknown>(
      {url: `/logs/stream/model/${modelId}/container/${containerName}`, method: 'GET', signal
    },
      );
    }
  

export const getStreamContainerLogsLogsStreamModelModelIdContainerContainerNameGetQueryKey = (modelId: string,
    containerName: string,) => {
    return [`/logs/stream/model/${modelId}/container/${containerName}`] as const;
    }

    
export const getStreamContainerLogsLogsStreamModelModelIdContainerContainerNameGetQueryOptions = <TData = Awaited<ReturnType<typeof streamContainerLogsLogsStreamModelModelIdContainerContainerNameGet>>, TError = HTTPValidationError>(modelId: string,
    containerName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamContainerLogsLogsStreamModelModelIdContainerContainerNameGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStreamContainerLogsLogsStreamModelModelIdContainerContainerNameGetQueryKey(modelId,containerName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof streamContainerLogsLogsStreamModelModelIdContainerContainerNameGet>>> = ({ signal }) => streamContainerLogsLogsStreamModelModelIdContainerContainerNameGet(modelId,containerName, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(modelId && containerName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof streamContainerLogsLogsStreamModelModelIdContainerContainerNameGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StreamContainerLogsLogsStreamModelModelIdContainerContainerNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof streamContainerLogsLogsStreamModelModelIdContainerContainerNameGet>>>
export type StreamContainerLogsLogsStreamModelModelIdContainerContainerNameGetQueryError = HTTPValidationError


export function useStreamContainerLogsLogsStreamModelModelIdContainerContainerNameGet<TData = Awaited<ReturnType<typeof streamContainerLogsLogsStreamModelModelIdContainerContainerNameGet>>, TError = HTTPValidationError>(
 modelId: string,
    containerName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamContainerLogsLogsStreamModelModelIdContainerContainerNameGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamContainerLogsLogsStreamModelModelIdContainerContainerNameGet>>,
          TError,
          Awaited<ReturnType<typeof streamContainerLogsLogsStreamModelModelIdContainerContainerNameGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStreamContainerLogsLogsStreamModelModelIdContainerContainerNameGet<TData = Awaited<ReturnType<typeof streamContainerLogsLogsStreamModelModelIdContainerContainerNameGet>>, TError = HTTPValidationError>(
 modelId: string,
    containerName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamContainerLogsLogsStreamModelModelIdContainerContainerNameGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamContainerLogsLogsStreamModelModelIdContainerContainerNameGet>>,
          TError,
          Awaited<ReturnType<typeof streamContainerLogsLogsStreamModelModelIdContainerContainerNameGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStreamContainerLogsLogsStreamModelModelIdContainerContainerNameGet<TData = Awaited<ReturnType<typeof streamContainerLogsLogsStreamModelModelIdContainerContainerNameGet>>, TError = HTTPValidationError>(
 modelId: string,
    containerName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamContainerLogsLogsStreamModelModelIdContainerContainerNameGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Stream Container Logs
 */

export function useStreamContainerLogsLogsStreamModelModelIdContainerContainerNameGet<TData = Awaited<ReturnType<typeof streamContainerLogsLogsStreamModelModelIdContainerContainerNameGet>>, TError = HTTPValidationError>(
 modelId: string,
    containerName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamContainerLogsLogsStreamModelModelIdContainerContainerNameGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStreamContainerLogsLogsStreamModelModelIdContainerContainerNameGetQueryOptions(modelId,containerName,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
