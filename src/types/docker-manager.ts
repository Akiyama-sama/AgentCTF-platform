/**
 * Generated by orval v7.9.0 🍺
 * Do not edit manually.
 * HackerLab API
 * 智能攻防靶场管理API
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { docker_manager_api } from '../utils/docker-manager-api';
/**
 * 响应数据
 */
export type ApiResponseData = unknown | null;

/**
 * 统一API响应格式
 */
export interface ApiResponse {
  /** 状态码 */
  code?: number;
  /** 响应消息 */
  message?: string;
  /** 响应数据 */
  data?: ApiResponseData;
}

/**
 * 响应数据
 */
export type ApiResponseComposeStatusResponseData = ComposeStatusResponse | null;

export interface ApiResponseComposeStatusResponse {
  /** 状态码 */
  code?: number;
  /** 响应消息 */
  message?: string;
  /** 响应数据 */
  data?: ApiResponseComposeStatusResponseData;
}

/**
 * 响应数据
 */
export type ApiResponseCreateExerciseWithFilesResponseData = CreateExerciseWithFilesResponse | null;

export interface ApiResponseCreateExerciseWithFilesResponse {
  /** 状态码 */
  code?: number;
  /** 响应消息 */
  message?: string;
  /** 响应数据 */
  data?: ApiResponseCreateExerciseWithFilesResponseData;
}

/**
 * 响应数据
 */
export type ApiResponseCreateScenarioWithFilesResponseData = CreateScenarioWithFilesResponse | null;

export interface ApiResponseCreateScenarioWithFilesResponse {
  /** 状态码 */
  code?: number;
  /** 响应消息 */
  message?: string;
  /** 响应数据 */
  data?: ApiResponseCreateScenarioWithFilesResponseData;
}

/**
 * 响应数据
 */
export type ApiResponseExerciseResponseData = ExerciseResponse | null;

export interface ApiResponseExerciseResponse {
  /** 状态码 */
  code?: number;
  /** 响应消息 */
  message?: string;
  /** 响应数据 */
  data?: ApiResponseExerciseResponseData;
}

/**
 * 响应数据
 */
export type ApiResponseExercisesListResponseData = ExercisesListResponse | null;

export interface ApiResponseExercisesListResponse {
  /** 状态码 */
  code?: number;
  /** 响应消息 */
  message?: string;
  /** 响应数据 */
  data?: ApiResponseExercisesListResponseData;
}

/**
 * 响应数据
 */
export type ApiResponseScenarioResponseData = ScenarioResponse | null;

export interface ApiResponseScenarioResponse {
  /** 状态码 */
  code?: number;
  /** 响应消息 */
  message?: string;
  /** 响应数据 */
  data?: ApiResponseScenarioResponseData;
}

/**
 * 响应数据
 */
export type ApiResponseScenarioStatusResponseData = ScenarioStatusResponse | null;

export interface ApiResponseScenarioStatusResponse {
  /** 状态码 */
  code?: number;
  /** 响应消息 */
  message?: string;
  /** 响应数据 */
  data?: ApiResponseScenarioStatusResponseData;
}

/**
 * 响应数据
 */
export type ApiResponseListContainerStatusResponseData = ContainerStatusResponse[] | null;

export interface ApiResponseListContainerStatusResponse {
  /** 状态码 */
  code?: number;
  /** 响应消息 */
  message?: string;
  /** 响应数据 */
  data?: ApiResponseListContainerStatusResponseData;
}

/**
 * 响应数据
 */
export type ApiResponseListScenarioResponseData = ScenarioResponse[] | null;

export interface ApiResponseListScenarioResponse {
  /** 状态码 */
  code?: number;
  /** 响应消息 */
  message?: string;
  /** 响应数据 */
  data?: ApiResponseListScenarioResponseData;
}

export interface BodyCreateExerciseExercisesPost {
  /** 练习名称 */
  name: string;
  /** 练习描述 */
  description: string;
  /** 靶机压缩包 */
  target_file: Blob;
}

export interface BodyCreateScenarioScenariosPost {
  /** 场景名称 */
  name: string;
  /** 场景描述 */
  description: string;
  /** 攻击端压缩包 */
  attacker_file: Blob;
  /** 防守端压缩包 */
  defender_file: Blob;
  /** 靶机压缩包 */
  target_file: Blob;
}

/**
 * Compose服务状态枚举
 */
export type ComposeStatus = typeof ComposeStatus[keyof typeof ComposeStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ComposeStatus = {
  stopped: 'stopped',
  starting: 'starting',
  running: 'running',
  stopping: 'stopping',
  error: 'error',
  not_found: 'not_found',
  unknown: 'unknown',
} as const;

/**
 * Compose状态响应模型
 */
export interface ComposeStatusResponse {
  attacker_status: ComposeStatus;
  defender_status: ComposeStatus;
  target_status: ComposeStatus;
  overall_status: ComposeStatus;
}

/**
 * 容器内部状态枚举
 */
export type ContainerState = typeof ContainerState[keyof typeof ContainerState];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ContainerState = {
  created: 'created',
  running: 'running',
  paused: 'paused',
  restarting: 'restarting',
  removing: 'removing',
  exited: 'exited',
  dead: 'dead',
  unknown: 'unknown',
  not_found: 'not_found',
} as const;

/**
 * 容器状态枚举
 */
export type ContainerStatus = typeof ContainerStatus[keyof typeof ContainerStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ContainerStatus = {
  created: 'created',
  restarting: 'restarting',
  running: 'running',
  removing: 'removing',
  paused: 'paused',
  exited: 'exited',
  dead: 'dead',
  not_found: 'not_found',
} as const;

/**
 * 容器状态响应模型
 */
export interface ContainerStatusResponse {
  container_id: string;
  name: string;
  status: ContainerStatus;
  state: ContainerState;
  image: string;
}

export type CreateExerciseWithFilesResponseUploadedFiles = { [key: string]: unknown };

/**
 * 创建练习（文件上传）响应模型
 */
export interface CreateExerciseWithFilesResponse {
  uuid: string;
  name: string;
  description: string;
  state: ExerciseState;
  file_path: string;
  uploaded_files?: CreateExerciseWithFilesResponseUploadedFiles;
}

export type CreateScenarioWithFilesResponseUploadedFiles = { [key: string]: unknown };

/**
 * 创建场景（文件上传）响应模型
 */
export interface CreateScenarioWithFilesResponse {
  uuid: string;
  name: string;
  description: string;
  state: ScenarioState;
  file_path: string;
  uploaded_files?: CreateScenarioWithFilesResponseUploadedFiles;
}

/**
 * 练习操作枚举
 */
export type ExerciseAction = typeof ExerciseAction[keyof typeof ExerciseAction];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ExerciseAction = {
  start: 'start',
  stop: 'stop',
  build: 'build',
} as const;

/**
 * 练习响应模型
 */
export interface ExerciseResponse {
  uuid: string;
  name: string;
  description: string;
  state: ExerciseState;
  file_path: string;
}

/**
 * 练习状态枚举
 */
export type ExerciseState = typeof ExerciseState[keyof typeof ExerciseState];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ExerciseState = {
  pending: 'pending',
  building: 'building',
  running: 'running',
  stopped: 'stopped',
  build_error: 'build_error',
  runtime_error: 'runtime_error',
  error: 'error',
  removing: 'removing',
} as const;

/**
 * 练习列表响应模型
 */
export interface ExercisesListResponse {
  exercises: ExerciseResponse[];
  count: number;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

/**
 * 练习名称
 */
export type PartialUpdateExerciseRequestName = string | null;

/**
 * 练习描述
 */
export type PartialUpdateExerciseRequestDescription = string | null;

/**
 * 部分更新练习请求模型
 */
export interface PartialUpdateExerciseRequest {
  /** 练习名称 */
  name?: PartialUpdateExerciseRequestName;
  /** 练习描述 */
  description?: PartialUpdateExerciseRequestDescription;
}

/**
 * 场景名称
 */
export type PartialUpdateScenarioRequestName = string | null;

/**
 * 场景描述
 */
export type PartialUpdateScenarioRequestDescription = string | null;

/**
 * 部分更新场景请求模型
 */
export interface PartialUpdateScenarioRequest {
  /** 场景名称 */
  name?: PartialUpdateScenarioRequestName;
  /** 场景描述 */
  description?: PartialUpdateScenarioRequestDescription;
}

/**
 * 场景操作枚举
 */
export type ScenarioAction = typeof ScenarioAction[keyof typeof ScenarioAction];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ScenarioAction = {
  start: 'start',
  stop: 'stop',
  build: 'build',
} as const;

/**
 * 场景响应模型
 */
export interface ScenarioResponse {
  uuid: string;
  name: string;
  description: string;
  state: ScenarioState;
  file_path: string;
}

/**
 * 场景状态枚举
 */
export type ScenarioState = typeof ScenarioState[keyof typeof ScenarioState];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ScenarioState = {
  pending: 'pending',
  building: 'building',
  running: 'running',
  stopped: 'stopped',
  build_error: 'build_error',
  runtime_error: 'runtime_error',
  error: 'error',
  removing: 'removing',
} as const;

export type ScenarioStatusResponseStatusInfo = { [key: string]: unknown };

/**
 * 场景状态响应模型
 */
export interface ScenarioStatusResponse {
  scenario_id: string;
  state: string;
  status_info: ScenarioStatusResponseStatusInfo;
}

/**
 * 场景目标状态枚举（用于设置状态）
 */
export type ScenarioTargetState = typeof ScenarioTargetState[keyof typeof ScenarioTargetState];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ScenarioTargetState = {
  running: 'running',
  stopped: 'stopped',
  building: 'building',
} as const;

/**
 * 设置场景状态请求模型
 */
export interface SetScenarioStateRequest {
  /** 目标状态 */
  state: ScenarioTargetState;
}

/**
 * 练习名称
 */
export type UpdateExerciseRequestName = string | null;

/**
 * 练习描述
 */
export type UpdateExerciseRequestDescription = string | null;

/**
 * 更新练习信息请求模型
 */
export interface UpdateExerciseRequest {
  /** 练习名称 */
  name?: UpdateExerciseRequestName;
  /** 练习描述 */
  description?: UpdateExerciseRequestDescription;
}

/**
 * 更新练习状态请求模型
 */
export interface UpdateExerciseStateRequest {
  /** 要执行的操作 */
  action: ExerciseAction;
}

/**
 * 场景名称
 */
export type UpdateScenarioRequestName = string | null;

/**
 * 场景描述
 */
export type UpdateScenarioRequestDescription = string | null;

/**
 * 更新场景信息请求模型
 */
export interface UpdateScenarioRequest {
  /** 场景名称 */
  name?: UpdateScenarioRequestName;
  /** 场景描述 */
  description?: UpdateScenarioRequestDescription;
}

/**
 * 更新场景状态请求模型
 */
export interface UpdateScenarioStateRequest {
  /** 要执行的操作 */
  action: ScenarioAction;
}

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

/**
 * 根路径
 * @summary Root
 */
export const rootGet = (
    
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<ApiResponse>(
      {url: `/`, method: 'GET', signal
    },
      );
    }
  

export const getRootGetQueryKey = () => {
    return [`/`] as const;
    }

    
export const getRootGetQueryOptions = <TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRootGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof rootGet>>> = ({ signal }) => rootGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type RootGetQueryResult = NonNullable<Awaited<ReturnType<typeof rootGet>>>
export type RootGetQueryError = unknown


export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof rootGet>>,
          TError,
          Awaited<ReturnType<typeof rootGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof rootGet>>,
          TError,
          Awaited<ReturnType<typeof rootGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Root
 */

export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getRootGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 健康检查
 * @summary Health Check
 */
export const healthCheckHealthGet = (
    
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<ApiResponse>(
      {url: `/health`, method: 'GET', signal
    },
      );
    }
  

export const getHealthCheckHealthGetQueryKey = () => {
    return [`/health`] as const;
    }

    
export const getHealthCheckHealthGetQueryOptions = <TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthCheckHealthGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheckHealthGet>>> = ({ signal }) => healthCheckHealthGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthCheckHealthGetQueryResult = NonNullable<Awaited<ReturnType<typeof healthCheckHealthGet>>>
export type HealthCheckHealthGetQueryError = unknown


export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckHealthGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckHealthGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Health Check
 */

export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHealthCheckHealthGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 获取所有场景列表
 * @summary Get Scenarios
 */
export const getScenariosScenariosGet = (
    
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<ApiResponseListScenarioResponse>(
      {url: `/scenarios`, method: 'GET', signal
    },
      );
    }
  

export const getGetScenariosScenariosGetQueryKey = () => {
    return [`/scenarios`] as const;
    }

    
export const getGetScenariosScenariosGetQueryOptions = <TData = Awaited<ReturnType<typeof getScenariosScenariosGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getScenariosScenariosGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetScenariosScenariosGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getScenariosScenariosGet>>> = ({ signal }) => getScenariosScenariosGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getScenariosScenariosGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetScenariosScenariosGetQueryResult = NonNullable<Awaited<ReturnType<typeof getScenariosScenariosGet>>>
export type GetScenariosScenariosGetQueryError = unknown


export function useGetScenariosScenariosGet<TData = Awaited<ReturnType<typeof getScenariosScenariosGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getScenariosScenariosGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getScenariosScenariosGet>>,
          TError,
          Awaited<ReturnType<typeof getScenariosScenariosGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetScenariosScenariosGet<TData = Awaited<ReturnType<typeof getScenariosScenariosGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getScenariosScenariosGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getScenariosScenariosGet>>,
          TError,
          Awaited<ReturnType<typeof getScenariosScenariosGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetScenariosScenariosGet<TData = Awaited<ReturnType<typeof getScenariosScenariosGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getScenariosScenariosGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Scenarios
 */

export function useGetScenariosScenariosGet<TData = Awaited<ReturnType<typeof getScenariosScenariosGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getScenariosScenariosGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetScenariosScenariosGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 创建新场景
 * @summary Create Scenario
 */
export const createScenarioScenariosPost = (
    bodyCreateScenarioScenariosPost: BodyCreateScenarioScenariosPost,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`name`, bodyCreateScenarioScenariosPost.name)
formData.append(`description`, bodyCreateScenarioScenariosPost.description)
formData.append(`attacker_file`, bodyCreateScenarioScenariosPost.attacker_file)
formData.append(`defender_file`, bodyCreateScenarioScenariosPost.defender_file)
formData.append(`target_file`, bodyCreateScenarioScenariosPost.target_file)

      return docker_manager_api<ApiResponseCreateScenarioWithFilesResponse>(
      {url: `/scenarios`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getCreateScenarioScenariosPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createScenarioScenariosPost>>, TError,{data: BodyCreateScenarioScenariosPost}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createScenarioScenariosPost>>, TError,{data: BodyCreateScenarioScenariosPost}, TContext> => {

const mutationKey = ['createScenarioScenariosPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createScenarioScenariosPost>>, {data: BodyCreateScenarioScenariosPost}> = (props) => {
          const {data} = props ?? {};

          return  createScenarioScenariosPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateScenarioScenariosPostMutationResult = NonNullable<Awaited<ReturnType<typeof createScenarioScenariosPost>>>
    export type CreateScenarioScenariosPostMutationBody = BodyCreateScenarioScenariosPost
    export type CreateScenarioScenariosPostMutationError = HTTPValidationError

    /**
 * @summary Create Scenario
 */
export const useCreateScenarioScenariosPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createScenarioScenariosPost>>, TError,{data: BodyCreateScenarioScenariosPost}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createScenarioScenariosPost>>,
        TError,
        {data: BodyCreateScenarioScenariosPost},
        TContext
      > => {

      const mutationOptions = getCreateScenarioScenariosPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 获取指定场景详情
 * @summary Get Scenario
 */
export const getScenarioScenariosScenarioIdGet = (
    scenarioId: string,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<ApiResponseScenarioResponse>(
      {url: `/scenarios/${scenarioId}`, method: 'GET', signal
    },
      );
    }
  

export const getGetScenarioScenariosScenarioIdGetQueryKey = (scenarioId: string,) => {
    return [`/scenarios/${scenarioId}`] as const;
    }

    
export const getGetScenarioScenariosScenarioIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getScenarioScenariosScenarioIdGet>>, TError = HTTPValidationError>(scenarioId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getScenarioScenariosScenarioIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetScenarioScenariosScenarioIdGetQueryKey(scenarioId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getScenarioScenariosScenarioIdGet>>> = ({ signal }) => getScenarioScenariosScenarioIdGet(scenarioId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(scenarioId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getScenarioScenariosScenarioIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetScenarioScenariosScenarioIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getScenarioScenariosScenarioIdGet>>>
export type GetScenarioScenariosScenarioIdGetQueryError = HTTPValidationError


export function useGetScenarioScenariosScenarioIdGet<TData = Awaited<ReturnType<typeof getScenarioScenariosScenarioIdGet>>, TError = HTTPValidationError>(
 scenarioId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getScenarioScenariosScenarioIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getScenarioScenariosScenarioIdGet>>,
          TError,
          Awaited<ReturnType<typeof getScenarioScenariosScenarioIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetScenarioScenariosScenarioIdGet<TData = Awaited<ReturnType<typeof getScenarioScenariosScenarioIdGet>>, TError = HTTPValidationError>(
 scenarioId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getScenarioScenariosScenarioIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getScenarioScenariosScenarioIdGet>>,
          TError,
          Awaited<ReturnType<typeof getScenarioScenariosScenarioIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetScenarioScenariosScenarioIdGet<TData = Awaited<ReturnType<typeof getScenarioScenariosScenarioIdGet>>, TError = HTTPValidationError>(
 scenarioId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getScenarioScenariosScenarioIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Scenario
 */

export function useGetScenarioScenariosScenarioIdGet<TData = Awaited<ReturnType<typeof getScenarioScenariosScenarioIdGet>>, TError = HTTPValidationError>(
 scenarioId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getScenarioScenariosScenarioIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetScenarioScenariosScenarioIdGetQueryOptions(scenarioId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 删除场景
 * @summary Delete Scenario
 */
export const deleteScenarioScenariosScenarioIdDelete = (
    scenarioId: string,
 ) => {
      
      
      return docker_manager_api<ApiResponse>(
      {url: `/scenarios/${scenarioId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteScenarioScenariosScenarioIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteScenarioScenariosScenarioIdDelete>>, TError,{scenarioId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteScenarioScenariosScenarioIdDelete>>, TError,{scenarioId: string}, TContext> => {

const mutationKey = ['deleteScenarioScenariosScenarioIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteScenarioScenariosScenarioIdDelete>>, {scenarioId: string}> = (props) => {
          const {scenarioId} = props ?? {};

          return  deleteScenarioScenariosScenarioIdDelete(scenarioId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteScenarioScenariosScenarioIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteScenarioScenariosScenarioIdDelete>>>
    
    export type DeleteScenarioScenariosScenarioIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Scenario
 */
export const useDeleteScenarioScenariosScenarioIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteScenarioScenariosScenarioIdDelete>>, TError,{scenarioId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteScenarioScenariosScenarioIdDelete>>,
        TError,
        {scenarioId: string},
        TContext
      > => {

      const mutationOptions = getDeleteScenarioScenariosScenarioIdDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 完整更新场景信息
 * @summary Update Scenario
 */
export const updateScenarioScenariosScenarioIdPut = (
    scenarioId: string,
    updateScenarioRequest: UpdateScenarioRequest,
 ) => {
      
      
      return docker_manager_api<ApiResponseScenarioResponse>(
      {url: `/scenarios/${scenarioId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateScenarioRequest
    },
      );
    }
  


export const getUpdateScenarioScenariosScenarioIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateScenarioScenariosScenarioIdPut>>, TError,{scenarioId: string;data: UpdateScenarioRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateScenarioScenariosScenarioIdPut>>, TError,{scenarioId: string;data: UpdateScenarioRequest}, TContext> => {

const mutationKey = ['updateScenarioScenariosScenarioIdPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateScenarioScenariosScenarioIdPut>>, {scenarioId: string;data: UpdateScenarioRequest}> = (props) => {
          const {scenarioId,data} = props ?? {};

          return  updateScenarioScenariosScenarioIdPut(scenarioId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateScenarioScenariosScenarioIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateScenarioScenariosScenarioIdPut>>>
    export type UpdateScenarioScenariosScenarioIdPutMutationBody = UpdateScenarioRequest
    export type UpdateScenarioScenariosScenarioIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Scenario
 */
export const useUpdateScenarioScenariosScenarioIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateScenarioScenariosScenarioIdPut>>, TError,{scenarioId: string;data: UpdateScenarioRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateScenarioScenariosScenarioIdPut>>,
        TError,
        {scenarioId: string;data: UpdateScenarioRequest},
        TContext
      > => {

      const mutationOptions = getUpdateScenarioScenariosScenarioIdPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 更新场景状态（RESTful方式）
 * @summary Update Scenario State
 */
export const updateScenarioStateScenariosScenarioIdPatch = (
    scenarioId: string,
    updateScenarioStateRequest: UpdateScenarioStateRequest,
 ) => {
      
      
      return docker_manager_api<ApiResponse>(
      {url: `/scenarios/${scenarioId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateScenarioStateRequest
    },
      );
    }
  


export const getUpdateScenarioStateScenariosScenarioIdPatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateScenarioStateScenariosScenarioIdPatch>>, TError,{scenarioId: string;data: UpdateScenarioStateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateScenarioStateScenariosScenarioIdPatch>>, TError,{scenarioId: string;data: UpdateScenarioStateRequest}, TContext> => {

const mutationKey = ['updateScenarioStateScenariosScenarioIdPatch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateScenarioStateScenariosScenarioIdPatch>>, {scenarioId: string;data: UpdateScenarioStateRequest}> = (props) => {
          const {scenarioId,data} = props ?? {};

          return  updateScenarioStateScenariosScenarioIdPatch(scenarioId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateScenarioStateScenariosScenarioIdPatchMutationResult = NonNullable<Awaited<ReturnType<typeof updateScenarioStateScenariosScenarioIdPatch>>>
    export type UpdateScenarioStateScenariosScenarioIdPatchMutationBody = UpdateScenarioStateRequest
    export type UpdateScenarioStateScenariosScenarioIdPatchMutationError = HTTPValidationError

    /**
 * @summary Update Scenario State
 */
export const useUpdateScenarioStateScenariosScenarioIdPatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateScenarioStateScenariosScenarioIdPatch>>, TError,{scenarioId: string;data: UpdateScenarioStateRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateScenarioStateScenariosScenarioIdPatch>>,
        TError,
        {scenarioId: string;data: UpdateScenarioStateRequest},
        TContext
      > => {

      const mutationOptions = getUpdateScenarioStateScenariosScenarioIdPatchMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 部分更新场景信息
 * @summary Partial Update Scenario
 */
export const partialUpdateScenarioScenariosScenarioIdInfoPatch = (
    scenarioId: string,
    partialUpdateScenarioRequest: PartialUpdateScenarioRequest,
 ) => {
      
      
      return docker_manager_api<ApiResponseScenarioResponse>(
      {url: `/scenarios/${scenarioId}/info`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: partialUpdateScenarioRequest
    },
      );
    }
  


export const getPartialUpdateScenarioScenariosScenarioIdInfoPatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof partialUpdateScenarioScenariosScenarioIdInfoPatch>>, TError,{scenarioId: string;data: PartialUpdateScenarioRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof partialUpdateScenarioScenariosScenarioIdInfoPatch>>, TError,{scenarioId: string;data: PartialUpdateScenarioRequest}, TContext> => {

const mutationKey = ['partialUpdateScenarioScenariosScenarioIdInfoPatch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof partialUpdateScenarioScenariosScenarioIdInfoPatch>>, {scenarioId: string;data: PartialUpdateScenarioRequest}> = (props) => {
          const {scenarioId,data} = props ?? {};

          return  partialUpdateScenarioScenariosScenarioIdInfoPatch(scenarioId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PartialUpdateScenarioScenariosScenarioIdInfoPatchMutationResult = NonNullable<Awaited<ReturnType<typeof partialUpdateScenarioScenariosScenarioIdInfoPatch>>>
    export type PartialUpdateScenarioScenariosScenarioIdInfoPatchMutationBody = PartialUpdateScenarioRequest
    export type PartialUpdateScenarioScenariosScenarioIdInfoPatchMutationError = HTTPValidationError

    /**
 * @summary Partial Update Scenario
 */
export const usePartialUpdateScenarioScenariosScenarioIdInfoPatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof partialUpdateScenarioScenariosScenarioIdInfoPatch>>, TError,{scenarioId: string;data: PartialUpdateScenarioRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof partialUpdateScenarioScenariosScenarioIdInfoPatch>>,
        TError,
        {scenarioId: string;data: PartialUpdateScenarioRequest},
        TContext
      > => {

      const mutationOptions = getPartialUpdateScenarioScenariosScenarioIdInfoPatchMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 设置场景状态（独立状态资源）
 * @summary Set Scenario State
 */
export const setScenarioStateScenariosScenarioIdStatePut = (
    scenarioId: string,
    setScenarioStateRequest: SetScenarioStateRequest,
 ) => {
      
      
      return docker_manager_api<ApiResponse>(
      {url: `/scenarios/${scenarioId}/state`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: setScenarioStateRequest
    },
      );
    }
  


export const getSetScenarioStateScenariosScenarioIdStatePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setScenarioStateScenariosScenarioIdStatePut>>, TError,{scenarioId: string;data: SetScenarioStateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof setScenarioStateScenariosScenarioIdStatePut>>, TError,{scenarioId: string;data: SetScenarioStateRequest}, TContext> => {

const mutationKey = ['setScenarioStateScenariosScenarioIdStatePut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof setScenarioStateScenariosScenarioIdStatePut>>, {scenarioId: string;data: SetScenarioStateRequest}> = (props) => {
          const {scenarioId,data} = props ?? {};

          return  setScenarioStateScenariosScenarioIdStatePut(scenarioId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SetScenarioStateScenariosScenarioIdStatePutMutationResult = NonNullable<Awaited<ReturnType<typeof setScenarioStateScenariosScenarioIdStatePut>>>
    export type SetScenarioStateScenariosScenarioIdStatePutMutationBody = SetScenarioStateRequest
    export type SetScenarioStateScenariosScenarioIdStatePutMutationError = HTTPValidationError

    /**
 * @summary Set Scenario State
 */
export const useSetScenarioStateScenariosScenarioIdStatePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setScenarioStateScenariosScenarioIdStatePut>>, TError,{scenarioId: string;data: SetScenarioStateRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof setScenarioStateScenariosScenarioIdStatePut>>,
        TError,
        {scenarioId: string;data: SetScenarioStateRequest},
        TContext
      > => {

      const mutationOptions = getSetScenarioStateScenariosScenarioIdStatePutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 获取场景状态
 * @summary Get Scenario Status
 */
export const getScenarioStatusScenariosScenarioIdStatusGet = (
    scenarioId: string,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<ApiResponseScenarioStatusResponse>(
      {url: `/scenarios/${scenarioId}/status`, method: 'GET', signal
    },
      );
    }
  

export const getGetScenarioStatusScenariosScenarioIdStatusGetQueryKey = (scenarioId: string,) => {
    return [`/scenarios/${scenarioId}/status`] as const;
    }

    
export const getGetScenarioStatusScenariosScenarioIdStatusGetQueryOptions = <TData = Awaited<ReturnType<typeof getScenarioStatusScenariosScenarioIdStatusGet>>, TError = HTTPValidationError>(scenarioId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getScenarioStatusScenariosScenarioIdStatusGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetScenarioStatusScenariosScenarioIdStatusGetQueryKey(scenarioId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getScenarioStatusScenariosScenarioIdStatusGet>>> = ({ signal }) => getScenarioStatusScenariosScenarioIdStatusGet(scenarioId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(scenarioId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getScenarioStatusScenariosScenarioIdStatusGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetScenarioStatusScenariosScenarioIdStatusGetQueryResult = NonNullable<Awaited<ReturnType<typeof getScenarioStatusScenariosScenarioIdStatusGet>>>
export type GetScenarioStatusScenariosScenarioIdStatusGetQueryError = HTTPValidationError


export function useGetScenarioStatusScenariosScenarioIdStatusGet<TData = Awaited<ReturnType<typeof getScenarioStatusScenariosScenarioIdStatusGet>>, TError = HTTPValidationError>(
 scenarioId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getScenarioStatusScenariosScenarioIdStatusGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getScenarioStatusScenariosScenarioIdStatusGet>>,
          TError,
          Awaited<ReturnType<typeof getScenarioStatusScenariosScenarioIdStatusGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetScenarioStatusScenariosScenarioIdStatusGet<TData = Awaited<ReturnType<typeof getScenarioStatusScenariosScenarioIdStatusGet>>, TError = HTTPValidationError>(
 scenarioId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getScenarioStatusScenariosScenarioIdStatusGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getScenarioStatusScenariosScenarioIdStatusGet>>,
          TError,
          Awaited<ReturnType<typeof getScenarioStatusScenariosScenarioIdStatusGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetScenarioStatusScenariosScenarioIdStatusGet<TData = Awaited<ReturnType<typeof getScenarioStatusScenariosScenarioIdStatusGet>>, TError = HTTPValidationError>(
 scenarioId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getScenarioStatusScenariosScenarioIdStatusGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Scenario Status
 */

export function useGetScenarioStatusScenariosScenarioIdStatusGet<TData = Awaited<ReturnType<typeof getScenarioStatusScenariosScenarioIdStatusGet>>, TError = HTTPValidationError>(
 scenarioId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getScenarioStatusScenariosScenarioIdStatusGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetScenarioStatusScenariosScenarioIdStatusGetQueryOptions(scenarioId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 获取场景中的所有容器
 * @summary Get Scenario Containers
 */
export const getScenarioContainersScenariosScenarioIdContainersGet = (
    scenarioId: string,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<ApiResponseListContainerStatusResponse>(
      {url: `/scenarios/${scenarioId}/containers`, method: 'GET', signal
    },
      );
    }
  

export const getGetScenarioContainersScenariosScenarioIdContainersGetQueryKey = (scenarioId: string,) => {
    return [`/scenarios/${scenarioId}/containers`] as const;
    }

    
export const getGetScenarioContainersScenariosScenarioIdContainersGetQueryOptions = <TData = Awaited<ReturnType<typeof getScenarioContainersScenariosScenarioIdContainersGet>>, TError = HTTPValidationError>(scenarioId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getScenarioContainersScenariosScenarioIdContainersGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetScenarioContainersScenariosScenarioIdContainersGetQueryKey(scenarioId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getScenarioContainersScenariosScenarioIdContainersGet>>> = ({ signal }) => getScenarioContainersScenariosScenarioIdContainersGet(scenarioId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(scenarioId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getScenarioContainersScenariosScenarioIdContainersGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetScenarioContainersScenariosScenarioIdContainersGetQueryResult = NonNullable<Awaited<ReturnType<typeof getScenarioContainersScenariosScenarioIdContainersGet>>>
export type GetScenarioContainersScenariosScenarioIdContainersGetQueryError = HTTPValidationError


export function useGetScenarioContainersScenariosScenarioIdContainersGet<TData = Awaited<ReturnType<typeof getScenarioContainersScenariosScenarioIdContainersGet>>, TError = HTTPValidationError>(
 scenarioId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getScenarioContainersScenariosScenarioIdContainersGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getScenarioContainersScenariosScenarioIdContainersGet>>,
          TError,
          Awaited<ReturnType<typeof getScenarioContainersScenariosScenarioIdContainersGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetScenarioContainersScenariosScenarioIdContainersGet<TData = Awaited<ReturnType<typeof getScenarioContainersScenariosScenarioIdContainersGet>>, TError = HTTPValidationError>(
 scenarioId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getScenarioContainersScenariosScenarioIdContainersGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getScenarioContainersScenariosScenarioIdContainersGet>>,
          TError,
          Awaited<ReturnType<typeof getScenarioContainersScenariosScenarioIdContainersGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetScenarioContainersScenariosScenarioIdContainersGet<TData = Awaited<ReturnType<typeof getScenarioContainersScenariosScenarioIdContainersGet>>, TError = HTTPValidationError>(
 scenarioId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getScenarioContainersScenariosScenarioIdContainersGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Scenario Containers
 */

export function useGetScenarioContainersScenariosScenarioIdContainersGet<TData = Awaited<ReturnType<typeof getScenarioContainersScenariosScenarioIdContainersGet>>, TError = HTTPValidationError>(
 scenarioId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getScenarioContainersScenariosScenarioIdContainersGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetScenarioContainersScenariosScenarioIdContainersGetQueryOptions(scenarioId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 流式获取服务器日志
 * @summary Stream Server Logs
 */
export const streamServerLogsLogsStreamServerGet = (
    
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<unknown>(
      {url: `/logs/stream/server`, method: 'GET', signal
    },
      );
    }
  

export const getStreamServerLogsLogsStreamServerGetQueryKey = () => {
    return [`/logs/stream/server`] as const;
    }

    
export const getStreamServerLogsLogsStreamServerGetQueryOptions = <TData = Awaited<ReturnType<typeof streamServerLogsLogsStreamServerGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamServerLogsLogsStreamServerGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStreamServerLogsLogsStreamServerGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof streamServerLogsLogsStreamServerGet>>> = ({ signal }) => streamServerLogsLogsStreamServerGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof streamServerLogsLogsStreamServerGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StreamServerLogsLogsStreamServerGetQueryResult = NonNullable<Awaited<ReturnType<typeof streamServerLogsLogsStreamServerGet>>>
export type StreamServerLogsLogsStreamServerGetQueryError = unknown


export function useStreamServerLogsLogsStreamServerGet<TData = Awaited<ReturnType<typeof streamServerLogsLogsStreamServerGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamServerLogsLogsStreamServerGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamServerLogsLogsStreamServerGet>>,
          TError,
          Awaited<ReturnType<typeof streamServerLogsLogsStreamServerGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStreamServerLogsLogsStreamServerGet<TData = Awaited<ReturnType<typeof streamServerLogsLogsStreamServerGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamServerLogsLogsStreamServerGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamServerLogsLogsStreamServerGet>>,
          TError,
          Awaited<ReturnType<typeof streamServerLogsLogsStreamServerGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStreamServerLogsLogsStreamServerGet<TData = Awaited<ReturnType<typeof streamServerLogsLogsStreamServerGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamServerLogsLogsStreamServerGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Stream Server Logs
 */

export function useStreamServerLogsLogsStreamServerGet<TData = Awaited<ReturnType<typeof streamServerLogsLogsStreamServerGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamServerLogsLogsStreamServerGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStreamServerLogsLogsStreamServerGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 流式获取场景构建日志
 * @summary Stream Scenario Build Logs
 */
export const streamScenarioBuildLogsLogsStreamScenarioScenarioIdBuildGet = (
    scenarioId: string,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<unknown>(
      {url: `/logs/stream/scenario/${scenarioId}/build`, method: 'GET', signal
    },
      );
    }
  

export const getStreamScenarioBuildLogsLogsStreamScenarioScenarioIdBuildGetQueryKey = (scenarioId: string,) => {
    return [`/logs/stream/scenario/${scenarioId}/build`] as const;
    }

    
export const getStreamScenarioBuildLogsLogsStreamScenarioScenarioIdBuildGetQueryOptions = <TData = Awaited<ReturnType<typeof streamScenarioBuildLogsLogsStreamScenarioScenarioIdBuildGet>>, TError = HTTPValidationError>(scenarioId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamScenarioBuildLogsLogsStreamScenarioScenarioIdBuildGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStreamScenarioBuildLogsLogsStreamScenarioScenarioIdBuildGetQueryKey(scenarioId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof streamScenarioBuildLogsLogsStreamScenarioScenarioIdBuildGet>>> = ({ signal }) => streamScenarioBuildLogsLogsStreamScenarioScenarioIdBuildGet(scenarioId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(scenarioId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof streamScenarioBuildLogsLogsStreamScenarioScenarioIdBuildGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StreamScenarioBuildLogsLogsStreamScenarioScenarioIdBuildGetQueryResult = NonNullable<Awaited<ReturnType<typeof streamScenarioBuildLogsLogsStreamScenarioScenarioIdBuildGet>>>
export type StreamScenarioBuildLogsLogsStreamScenarioScenarioIdBuildGetQueryError = HTTPValidationError


export function useStreamScenarioBuildLogsLogsStreamScenarioScenarioIdBuildGet<TData = Awaited<ReturnType<typeof streamScenarioBuildLogsLogsStreamScenarioScenarioIdBuildGet>>, TError = HTTPValidationError>(
 scenarioId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamScenarioBuildLogsLogsStreamScenarioScenarioIdBuildGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamScenarioBuildLogsLogsStreamScenarioScenarioIdBuildGet>>,
          TError,
          Awaited<ReturnType<typeof streamScenarioBuildLogsLogsStreamScenarioScenarioIdBuildGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStreamScenarioBuildLogsLogsStreamScenarioScenarioIdBuildGet<TData = Awaited<ReturnType<typeof streamScenarioBuildLogsLogsStreamScenarioScenarioIdBuildGet>>, TError = HTTPValidationError>(
 scenarioId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamScenarioBuildLogsLogsStreamScenarioScenarioIdBuildGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamScenarioBuildLogsLogsStreamScenarioScenarioIdBuildGet>>,
          TError,
          Awaited<ReturnType<typeof streamScenarioBuildLogsLogsStreamScenarioScenarioIdBuildGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStreamScenarioBuildLogsLogsStreamScenarioScenarioIdBuildGet<TData = Awaited<ReturnType<typeof streamScenarioBuildLogsLogsStreamScenarioScenarioIdBuildGet>>, TError = HTTPValidationError>(
 scenarioId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamScenarioBuildLogsLogsStreamScenarioScenarioIdBuildGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Stream Scenario Build Logs
 */

export function useStreamScenarioBuildLogsLogsStreamScenarioScenarioIdBuildGet<TData = Awaited<ReturnType<typeof streamScenarioBuildLogsLogsStreamScenarioScenarioIdBuildGet>>, TError = HTTPValidationError>(
 scenarioId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamScenarioBuildLogsLogsStreamScenarioScenarioIdBuildGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStreamScenarioBuildLogsLogsStreamScenarioScenarioIdBuildGetQueryOptions(scenarioId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 流式获取场景容器日志
 * @summary Stream Scenario Container Logs
 */
export const streamScenarioContainerLogsLogsStreamScenarioScenarioIdContainersGet = (
    scenarioId: string,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<unknown>(
      {url: `/logs/stream/scenario/${scenarioId}/containers`, method: 'GET', signal
    },
      );
    }
  

export const getStreamScenarioContainerLogsLogsStreamScenarioScenarioIdContainersGetQueryKey = (scenarioId: string,) => {
    return [`/logs/stream/scenario/${scenarioId}/containers`] as const;
    }

    
export const getStreamScenarioContainerLogsLogsStreamScenarioScenarioIdContainersGetQueryOptions = <TData = Awaited<ReturnType<typeof streamScenarioContainerLogsLogsStreamScenarioScenarioIdContainersGet>>, TError = HTTPValidationError>(scenarioId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamScenarioContainerLogsLogsStreamScenarioScenarioIdContainersGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStreamScenarioContainerLogsLogsStreamScenarioScenarioIdContainersGetQueryKey(scenarioId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof streamScenarioContainerLogsLogsStreamScenarioScenarioIdContainersGet>>> = ({ signal }) => streamScenarioContainerLogsLogsStreamScenarioScenarioIdContainersGet(scenarioId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(scenarioId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof streamScenarioContainerLogsLogsStreamScenarioScenarioIdContainersGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StreamScenarioContainerLogsLogsStreamScenarioScenarioIdContainersGetQueryResult = NonNullable<Awaited<ReturnType<typeof streamScenarioContainerLogsLogsStreamScenarioScenarioIdContainersGet>>>
export type StreamScenarioContainerLogsLogsStreamScenarioScenarioIdContainersGetQueryError = HTTPValidationError


export function useStreamScenarioContainerLogsLogsStreamScenarioScenarioIdContainersGet<TData = Awaited<ReturnType<typeof streamScenarioContainerLogsLogsStreamScenarioScenarioIdContainersGet>>, TError = HTTPValidationError>(
 scenarioId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamScenarioContainerLogsLogsStreamScenarioScenarioIdContainersGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamScenarioContainerLogsLogsStreamScenarioScenarioIdContainersGet>>,
          TError,
          Awaited<ReturnType<typeof streamScenarioContainerLogsLogsStreamScenarioScenarioIdContainersGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStreamScenarioContainerLogsLogsStreamScenarioScenarioIdContainersGet<TData = Awaited<ReturnType<typeof streamScenarioContainerLogsLogsStreamScenarioScenarioIdContainersGet>>, TError = HTTPValidationError>(
 scenarioId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamScenarioContainerLogsLogsStreamScenarioScenarioIdContainersGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamScenarioContainerLogsLogsStreamScenarioScenarioIdContainersGet>>,
          TError,
          Awaited<ReturnType<typeof streamScenarioContainerLogsLogsStreamScenarioScenarioIdContainersGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStreamScenarioContainerLogsLogsStreamScenarioScenarioIdContainersGet<TData = Awaited<ReturnType<typeof streamScenarioContainerLogsLogsStreamScenarioScenarioIdContainersGet>>, TError = HTTPValidationError>(
 scenarioId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamScenarioContainerLogsLogsStreamScenarioScenarioIdContainersGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Stream Scenario Container Logs
 */

export function useStreamScenarioContainerLogsLogsStreamScenarioScenarioIdContainersGet<TData = Awaited<ReturnType<typeof streamScenarioContainerLogsLogsStreamScenarioScenarioIdContainersGet>>, TError = HTTPValidationError>(
 scenarioId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamScenarioContainerLogsLogsStreamScenarioScenarioIdContainersGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStreamScenarioContainerLogsLogsStreamScenarioScenarioIdContainersGetQueryOptions(scenarioId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 流式获取场景日志
 * @summary Stream Scenario Logs
 */
export const streamScenarioLogsLogsStreamScenarioScenarioIdGet = (
    scenarioId: string,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<unknown>(
      {url: `/logs/stream/scenario/${scenarioId}`, method: 'GET', signal
    },
      );
    }
  

export const getStreamScenarioLogsLogsStreamScenarioScenarioIdGetQueryKey = (scenarioId: string,) => {
    return [`/logs/stream/scenario/${scenarioId}`] as const;
    }

    
export const getStreamScenarioLogsLogsStreamScenarioScenarioIdGetQueryOptions = <TData = Awaited<ReturnType<typeof streamScenarioLogsLogsStreamScenarioScenarioIdGet>>, TError = HTTPValidationError>(scenarioId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamScenarioLogsLogsStreamScenarioScenarioIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStreamScenarioLogsLogsStreamScenarioScenarioIdGetQueryKey(scenarioId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof streamScenarioLogsLogsStreamScenarioScenarioIdGet>>> = ({ signal }) => streamScenarioLogsLogsStreamScenarioScenarioIdGet(scenarioId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(scenarioId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof streamScenarioLogsLogsStreamScenarioScenarioIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StreamScenarioLogsLogsStreamScenarioScenarioIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof streamScenarioLogsLogsStreamScenarioScenarioIdGet>>>
export type StreamScenarioLogsLogsStreamScenarioScenarioIdGetQueryError = HTTPValidationError


export function useStreamScenarioLogsLogsStreamScenarioScenarioIdGet<TData = Awaited<ReturnType<typeof streamScenarioLogsLogsStreamScenarioScenarioIdGet>>, TError = HTTPValidationError>(
 scenarioId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamScenarioLogsLogsStreamScenarioScenarioIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamScenarioLogsLogsStreamScenarioScenarioIdGet>>,
          TError,
          Awaited<ReturnType<typeof streamScenarioLogsLogsStreamScenarioScenarioIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStreamScenarioLogsLogsStreamScenarioScenarioIdGet<TData = Awaited<ReturnType<typeof streamScenarioLogsLogsStreamScenarioScenarioIdGet>>, TError = HTTPValidationError>(
 scenarioId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamScenarioLogsLogsStreamScenarioScenarioIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamScenarioLogsLogsStreamScenarioScenarioIdGet>>,
          TError,
          Awaited<ReturnType<typeof streamScenarioLogsLogsStreamScenarioScenarioIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStreamScenarioLogsLogsStreamScenarioScenarioIdGet<TData = Awaited<ReturnType<typeof streamScenarioLogsLogsStreamScenarioScenarioIdGet>>, TError = HTTPValidationError>(
 scenarioId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamScenarioLogsLogsStreamScenarioScenarioIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Stream Scenario Logs
 */

export function useStreamScenarioLogsLogsStreamScenarioScenarioIdGet<TData = Awaited<ReturnType<typeof streamScenarioLogsLogsStreamScenarioScenarioIdGet>>, TError = HTTPValidationError>(
 scenarioId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamScenarioLogsLogsStreamScenarioScenarioIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStreamScenarioLogsLogsStreamScenarioScenarioIdGetQueryOptions(scenarioId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 流式获取指定容器的日志
 * @summary Stream Container Logs
 */
export const streamContainerLogsLogsStreamScenarioScenarioIdContainerContainerNameGet = (
    scenarioId: string,
    containerName: string,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<unknown>(
      {url: `/logs/stream/scenario/${scenarioId}/container/${containerName}`, method: 'GET', signal
    },
      );
    }
  

export const getStreamContainerLogsLogsStreamScenarioScenarioIdContainerContainerNameGetQueryKey = (scenarioId: string,
    containerName: string,) => {
    return [`/logs/stream/scenario/${scenarioId}/container/${containerName}`] as const;
    }

    
export const getStreamContainerLogsLogsStreamScenarioScenarioIdContainerContainerNameGetQueryOptions = <TData = Awaited<ReturnType<typeof streamContainerLogsLogsStreamScenarioScenarioIdContainerContainerNameGet>>, TError = HTTPValidationError>(scenarioId: string,
    containerName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamContainerLogsLogsStreamScenarioScenarioIdContainerContainerNameGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStreamContainerLogsLogsStreamScenarioScenarioIdContainerContainerNameGetQueryKey(scenarioId,containerName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof streamContainerLogsLogsStreamScenarioScenarioIdContainerContainerNameGet>>> = ({ signal }) => streamContainerLogsLogsStreamScenarioScenarioIdContainerContainerNameGet(scenarioId,containerName, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(scenarioId && containerName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof streamContainerLogsLogsStreamScenarioScenarioIdContainerContainerNameGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StreamContainerLogsLogsStreamScenarioScenarioIdContainerContainerNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof streamContainerLogsLogsStreamScenarioScenarioIdContainerContainerNameGet>>>
export type StreamContainerLogsLogsStreamScenarioScenarioIdContainerContainerNameGetQueryError = HTTPValidationError


export function useStreamContainerLogsLogsStreamScenarioScenarioIdContainerContainerNameGet<TData = Awaited<ReturnType<typeof streamContainerLogsLogsStreamScenarioScenarioIdContainerContainerNameGet>>, TError = HTTPValidationError>(
 scenarioId: string,
    containerName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamContainerLogsLogsStreamScenarioScenarioIdContainerContainerNameGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamContainerLogsLogsStreamScenarioScenarioIdContainerContainerNameGet>>,
          TError,
          Awaited<ReturnType<typeof streamContainerLogsLogsStreamScenarioScenarioIdContainerContainerNameGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStreamContainerLogsLogsStreamScenarioScenarioIdContainerContainerNameGet<TData = Awaited<ReturnType<typeof streamContainerLogsLogsStreamScenarioScenarioIdContainerContainerNameGet>>, TError = HTTPValidationError>(
 scenarioId: string,
    containerName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamContainerLogsLogsStreamScenarioScenarioIdContainerContainerNameGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamContainerLogsLogsStreamScenarioScenarioIdContainerContainerNameGet>>,
          TError,
          Awaited<ReturnType<typeof streamContainerLogsLogsStreamScenarioScenarioIdContainerContainerNameGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStreamContainerLogsLogsStreamScenarioScenarioIdContainerContainerNameGet<TData = Awaited<ReturnType<typeof streamContainerLogsLogsStreamScenarioScenarioIdContainerContainerNameGet>>, TError = HTTPValidationError>(
 scenarioId: string,
    containerName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamContainerLogsLogsStreamScenarioScenarioIdContainerContainerNameGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Stream Container Logs
 */

export function useStreamContainerLogsLogsStreamScenarioScenarioIdContainerContainerNameGet<TData = Awaited<ReturnType<typeof streamContainerLogsLogsStreamScenarioScenarioIdContainerContainerNameGet>>, TError = HTTPValidationError>(
 scenarioId: string,
    containerName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamContainerLogsLogsStreamScenarioScenarioIdContainerContainerNameGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStreamContainerLogsLogsStreamScenarioScenarioIdContainerContainerNameGetQueryOptions(scenarioId,containerName,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 获取所有练习列表
 * @summary Get Exercises
 */
export const getExercisesExercisesGet = (
    
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<ApiResponseExercisesListResponse>(
      {url: `/exercises`, method: 'GET', signal
    },
      );
    }
  

export const getGetExercisesExercisesGetQueryKey = () => {
    return [`/exercises`] as const;
    }

    
export const getGetExercisesExercisesGetQueryOptions = <TData = Awaited<ReturnType<typeof getExercisesExercisesGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExercisesExercisesGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExercisesExercisesGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExercisesExercisesGet>>> = ({ signal }) => getExercisesExercisesGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getExercisesExercisesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetExercisesExercisesGetQueryResult = NonNullable<Awaited<ReturnType<typeof getExercisesExercisesGet>>>
export type GetExercisesExercisesGetQueryError = unknown


export function useGetExercisesExercisesGet<TData = Awaited<ReturnType<typeof getExercisesExercisesGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExercisesExercisesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExercisesExercisesGet>>,
          TError,
          Awaited<ReturnType<typeof getExercisesExercisesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExercisesExercisesGet<TData = Awaited<ReturnType<typeof getExercisesExercisesGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExercisesExercisesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExercisesExercisesGet>>,
          TError,
          Awaited<ReturnType<typeof getExercisesExercisesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExercisesExercisesGet<TData = Awaited<ReturnType<typeof getExercisesExercisesGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExercisesExercisesGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Exercises
 */

export function useGetExercisesExercisesGet<TData = Awaited<ReturnType<typeof getExercisesExercisesGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExercisesExercisesGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetExercisesExercisesGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 创建新练习
 * @summary Create Exercise
 */
export const createExerciseExercisesPost = (
    bodyCreateExerciseExercisesPost: BodyCreateExerciseExercisesPost,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`name`, bodyCreateExerciseExercisesPost.name)
formData.append(`description`, bodyCreateExerciseExercisesPost.description)
formData.append(`target_file`, bodyCreateExerciseExercisesPost.target_file)

      return docker_manager_api<ApiResponseCreateExerciseWithFilesResponse>(
      {url: `/exercises`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getCreateExerciseExercisesPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createExerciseExercisesPost>>, TError,{data: BodyCreateExerciseExercisesPost}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createExerciseExercisesPost>>, TError,{data: BodyCreateExerciseExercisesPost}, TContext> => {

const mutationKey = ['createExerciseExercisesPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createExerciseExercisesPost>>, {data: BodyCreateExerciseExercisesPost}> = (props) => {
          const {data} = props ?? {};

          return  createExerciseExercisesPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateExerciseExercisesPostMutationResult = NonNullable<Awaited<ReturnType<typeof createExerciseExercisesPost>>>
    export type CreateExerciseExercisesPostMutationBody = BodyCreateExerciseExercisesPost
    export type CreateExerciseExercisesPostMutationError = HTTPValidationError

    /**
 * @summary Create Exercise
 */
export const useCreateExerciseExercisesPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createExerciseExercisesPost>>, TError,{data: BodyCreateExerciseExercisesPost}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createExerciseExercisesPost>>,
        TError,
        {data: BodyCreateExerciseExercisesPost},
        TContext
      > => {

      const mutationOptions = getCreateExerciseExercisesPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 获取指定练习详情
 * @summary Get Exercise
 */
export const getExerciseExercisesExerciseIdGet = (
    exerciseId: string,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<ApiResponseExerciseResponse>(
      {url: `/exercises/${exerciseId}`, method: 'GET', signal
    },
      );
    }
  

export const getGetExerciseExercisesExerciseIdGetQueryKey = (exerciseId: string,) => {
    return [`/exercises/${exerciseId}`] as const;
    }

    
export const getGetExerciseExercisesExerciseIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getExerciseExercisesExerciseIdGet>>, TError = HTTPValidationError>(exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExerciseExercisesExerciseIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExerciseExercisesExerciseIdGetQueryKey(exerciseId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExerciseExercisesExerciseIdGet>>> = ({ signal }) => getExerciseExercisesExerciseIdGet(exerciseId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(exerciseId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getExerciseExercisesExerciseIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetExerciseExercisesExerciseIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getExerciseExercisesExerciseIdGet>>>
export type GetExerciseExercisesExerciseIdGetQueryError = HTTPValidationError


export function useGetExerciseExercisesExerciseIdGet<TData = Awaited<ReturnType<typeof getExerciseExercisesExerciseIdGet>>, TError = HTTPValidationError>(
 exerciseId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExerciseExercisesExerciseIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExerciseExercisesExerciseIdGet>>,
          TError,
          Awaited<ReturnType<typeof getExerciseExercisesExerciseIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExerciseExercisesExerciseIdGet<TData = Awaited<ReturnType<typeof getExerciseExercisesExerciseIdGet>>, TError = HTTPValidationError>(
 exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExerciseExercisesExerciseIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExerciseExercisesExerciseIdGet>>,
          TError,
          Awaited<ReturnType<typeof getExerciseExercisesExerciseIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExerciseExercisesExerciseIdGet<TData = Awaited<ReturnType<typeof getExerciseExercisesExerciseIdGet>>, TError = HTTPValidationError>(
 exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExerciseExercisesExerciseIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Exercise
 */

export function useGetExerciseExercisesExerciseIdGet<TData = Awaited<ReturnType<typeof getExerciseExercisesExerciseIdGet>>, TError = HTTPValidationError>(
 exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExerciseExercisesExerciseIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetExerciseExercisesExerciseIdGetQueryOptions(exerciseId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 删除练习
 * @summary Delete Exercise
 */
export const deleteExerciseExercisesExerciseIdDelete = (
    exerciseId: string,
 ) => {
      
      
      return docker_manager_api<ApiResponse>(
      {url: `/exercises/${exerciseId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteExerciseExercisesExerciseIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteExerciseExercisesExerciseIdDelete>>, TError,{exerciseId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteExerciseExercisesExerciseIdDelete>>, TError,{exerciseId: string}, TContext> => {

const mutationKey = ['deleteExerciseExercisesExerciseIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteExerciseExercisesExerciseIdDelete>>, {exerciseId: string}> = (props) => {
          const {exerciseId} = props ?? {};

          return  deleteExerciseExercisesExerciseIdDelete(exerciseId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteExerciseExercisesExerciseIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteExerciseExercisesExerciseIdDelete>>>
    
    export type DeleteExerciseExercisesExerciseIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Exercise
 */
export const useDeleteExerciseExercisesExerciseIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteExerciseExercisesExerciseIdDelete>>, TError,{exerciseId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteExerciseExercisesExerciseIdDelete>>,
        TError,
        {exerciseId: string},
        TContext
      > => {

      const mutationOptions = getDeleteExerciseExercisesExerciseIdDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 完整更新练习信息
 * @summary Update Exercise
 */
export const updateExerciseExercisesExerciseIdPut = (
    exerciseId: string,
    updateExerciseRequest: UpdateExerciseRequest,
 ) => {
      
      
      return docker_manager_api<ApiResponseExerciseResponse>(
      {url: `/exercises/${exerciseId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateExerciseRequest
    },
      );
    }
  


export const getUpdateExerciseExercisesExerciseIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateExerciseExercisesExerciseIdPut>>, TError,{exerciseId: string;data: UpdateExerciseRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateExerciseExercisesExerciseIdPut>>, TError,{exerciseId: string;data: UpdateExerciseRequest}, TContext> => {

const mutationKey = ['updateExerciseExercisesExerciseIdPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateExerciseExercisesExerciseIdPut>>, {exerciseId: string;data: UpdateExerciseRequest}> = (props) => {
          const {exerciseId,data} = props ?? {};

          return  updateExerciseExercisesExerciseIdPut(exerciseId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateExerciseExercisesExerciseIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateExerciseExercisesExerciseIdPut>>>
    export type UpdateExerciseExercisesExerciseIdPutMutationBody = UpdateExerciseRequest
    export type UpdateExerciseExercisesExerciseIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Exercise
 */
export const useUpdateExerciseExercisesExerciseIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateExerciseExercisesExerciseIdPut>>, TError,{exerciseId: string;data: UpdateExerciseRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateExerciseExercisesExerciseIdPut>>,
        TError,
        {exerciseId: string;data: UpdateExerciseRequest},
        TContext
      > => {

      const mutationOptions = getUpdateExerciseExercisesExerciseIdPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 更新练习状态
 * @summary Update Exercise State
 */
export const updateExerciseStateExercisesExerciseIdPatch = (
    exerciseId: string,
    updateExerciseStateRequest: UpdateExerciseStateRequest,
 ) => {
      
      
      return docker_manager_api<ApiResponse>(
      {url: `/exercises/${exerciseId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateExerciseStateRequest
    },
      );
    }
  


export const getUpdateExerciseStateExercisesExerciseIdPatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateExerciseStateExercisesExerciseIdPatch>>, TError,{exerciseId: string;data: UpdateExerciseStateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateExerciseStateExercisesExerciseIdPatch>>, TError,{exerciseId: string;data: UpdateExerciseStateRequest}, TContext> => {

const mutationKey = ['updateExerciseStateExercisesExerciseIdPatch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateExerciseStateExercisesExerciseIdPatch>>, {exerciseId: string;data: UpdateExerciseStateRequest}> = (props) => {
          const {exerciseId,data} = props ?? {};

          return  updateExerciseStateExercisesExerciseIdPatch(exerciseId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateExerciseStateExercisesExerciseIdPatchMutationResult = NonNullable<Awaited<ReturnType<typeof updateExerciseStateExercisesExerciseIdPatch>>>
    export type UpdateExerciseStateExercisesExerciseIdPatchMutationBody = UpdateExerciseStateRequest
    export type UpdateExerciseStateExercisesExerciseIdPatchMutationError = HTTPValidationError

    /**
 * @summary Update Exercise State
 */
export const useUpdateExerciseStateExercisesExerciseIdPatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateExerciseStateExercisesExerciseIdPatch>>, TError,{exerciseId: string;data: UpdateExerciseStateRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateExerciseStateExercisesExerciseIdPatch>>,
        TError,
        {exerciseId: string;data: UpdateExerciseStateRequest},
        TContext
      > => {

      const mutationOptions = getUpdateExerciseStateExercisesExerciseIdPatchMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 部分更新练习信息
 * @summary Partial Update Exercise
 */
export const partialUpdateExerciseExercisesExerciseIdInfoPatch = (
    exerciseId: string,
    partialUpdateExerciseRequest: PartialUpdateExerciseRequest,
 ) => {
      
      
      return docker_manager_api<ApiResponseExerciseResponse>(
      {url: `/exercises/${exerciseId}/info`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: partialUpdateExerciseRequest
    },
      );
    }
  


export const getPartialUpdateExerciseExercisesExerciseIdInfoPatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof partialUpdateExerciseExercisesExerciseIdInfoPatch>>, TError,{exerciseId: string;data: PartialUpdateExerciseRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof partialUpdateExerciseExercisesExerciseIdInfoPatch>>, TError,{exerciseId: string;data: PartialUpdateExerciseRequest}, TContext> => {

const mutationKey = ['partialUpdateExerciseExercisesExerciseIdInfoPatch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof partialUpdateExerciseExercisesExerciseIdInfoPatch>>, {exerciseId: string;data: PartialUpdateExerciseRequest}> = (props) => {
          const {exerciseId,data} = props ?? {};

          return  partialUpdateExerciseExercisesExerciseIdInfoPatch(exerciseId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PartialUpdateExerciseExercisesExerciseIdInfoPatchMutationResult = NonNullable<Awaited<ReturnType<typeof partialUpdateExerciseExercisesExerciseIdInfoPatch>>>
    export type PartialUpdateExerciseExercisesExerciseIdInfoPatchMutationBody = PartialUpdateExerciseRequest
    export type PartialUpdateExerciseExercisesExerciseIdInfoPatchMutationError = HTTPValidationError

    /**
 * @summary Partial Update Exercise
 */
export const usePartialUpdateExerciseExercisesExerciseIdInfoPatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof partialUpdateExerciseExercisesExerciseIdInfoPatch>>, TError,{exerciseId: string;data: PartialUpdateExerciseRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof partialUpdateExerciseExercisesExerciseIdInfoPatch>>,
        TError,
        {exerciseId: string;data: PartialUpdateExerciseRequest},
        TContext
      > => {

      const mutationOptions = getPartialUpdateExerciseExercisesExerciseIdInfoPatchMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 获取练习状态
 * @summary Get Exercise Status
 */
export const getExerciseStatusExercisesExerciseIdStatusGet = (
    exerciseId: string,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<ApiResponseComposeStatusResponse>(
      {url: `/exercises/${exerciseId}/status`, method: 'GET', signal
    },
      );
    }
  

export const getGetExerciseStatusExercisesExerciseIdStatusGetQueryKey = (exerciseId: string,) => {
    return [`/exercises/${exerciseId}/status`] as const;
    }

    
export const getGetExerciseStatusExercisesExerciseIdStatusGetQueryOptions = <TData = Awaited<ReturnType<typeof getExerciseStatusExercisesExerciseIdStatusGet>>, TError = HTTPValidationError>(exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExerciseStatusExercisesExerciseIdStatusGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExerciseStatusExercisesExerciseIdStatusGetQueryKey(exerciseId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExerciseStatusExercisesExerciseIdStatusGet>>> = ({ signal }) => getExerciseStatusExercisesExerciseIdStatusGet(exerciseId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(exerciseId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getExerciseStatusExercisesExerciseIdStatusGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetExerciseStatusExercisesExerciseIdStatusGetQueryResult = NonNullable<Awaited<ReturnType<typeof getExerciseStatusExercisesExerciseIdStatusGet>>>
export type GetExerciseStatusExercisesExerciseIdStatusGetQueryError = HTTPValidationError


export function useGetExerciseStatusExercisesExerciseIdStatusGet<TData = Awaited<ReturnType<typeof getExerciseStatusExercisesExerciseIdStatusGet>>, TError = HTTPValidationError>(
 exerciseId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExerciseStatusExercisesExerciseIdStatusGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExerciseStatusExercisesExerciseIdStatusGet>>,
          TError,
          Awaited<ReturnType<typeof getExerciseStatusExercisesExerciseIdStatusGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExerciseStatusExercisesExerciseIdStatusGet<TData = Awaited<ReturnType<typeof getExerciseStatusExercisesExerciseIdStatusGet>>, TError = HTTPValidationError>(
 exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExerciseStatusExercisesExerciseIdStatusGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExerciseStatusExercisesExerciseIdStatusGet>>,
          TError,
          Awaited<ReturnType<typeof getExerciseStatusExercisesExerciseIdStatusGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExerciseStatusExercisesExerciseIdStatusGet<TData = Awaited<ReturnType<typeof getExerciseStatusExercisesExerciseIdStatusGet>>, TError = HTTPValidationError>(
 exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExerciseStatusExercisesExerciseIdStatusGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Exercise Status
 */

export function useGetExerciseStatusExercisesExerciseIdStatusGet<TData = Awaited<ReturnType<typeof getExerciseStatusExercisesExerciseIdStatusGet>>, TError = HTTPValidationError>(
 exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExerciseStatusExercisesExerciseIdStatusGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetExerciseStatusExercisesExerciseIdStatusGetQueryOptions(exerciseId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 获取练习容器信息
 * @summary Get Exercise Containers
 */
export const getExerciseContainersExercisesExerciseIdContainersGet = (
    exerciseId: string,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<ApiResponseListContainerStatusResponse>(
      {url: `/exercises/${exerciseId}/containers`, method: 'GET', signal
    },
      );
    }
  

export const getGetExerciseContainersExercisesExerciseIdContainersGetQueryKey = (exerciseId: string,) => {
    return [`/exercises/${exerciseId}/containers`] as const;
    }

    
export const getGetExerciseContainersExercisesExerciseIdContainersGetQueryOptions = <TData = Awaited<ReturnType<typeof getExerciseContainersExercisesExerciseIdContainersGet>>, TError = HTTPValidationError>(exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExerciseContainersExercisesExerciseIdContainersGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExerciseContainersExercisesExerciseIdContainersGetQueryKey(exerciseId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExerciseContainersExercisesExerciseIdContainersGet>>> = ({ signal }) => getExerciseContainersExercisesExerciseIdContainersGet(exerciseId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(exerciseId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getExerciseContainersExercisesExerciseIdContainersGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetExerciseContainersExercisesExerciseIdContainersGetQueryResult = NonNullable<Awaited<ReturnType<typeof getExerciseContainersExercisesExerciseIdContainersGet>>>
export type GetExerciseContainersExercisesExerciseIdContainersGetQueryError = HTTPValidationError


export function useGetExerciseContainersExercisesExerciseIdContainersGet<TData = Awaited<ReturnType<typeof getExerciseContainersExercisesExerciseIdContainersGet>>, TError = HTTPValidationError>(
 exerciseId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExerciseContainersExercisesExerciseIdContainersGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExerciseContainersExercisesExerciseIdContainersGet>>,
          TError,
          Awaited<ReturnType<typeof getExerciseContainersExercisesExerciseIdContainersGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExerciseContainersExercisesExerciseIdContainersGet<TData = Awaited<ReturnType<typeof getExerciseContainersExercisesExerciseIdContainersGet>>, TError = HTTPValidationError>(
 exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExerciseContainersExercisesExerciseIdContainersGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExerciseContainersExercisesExerciseIdContainersGet>>,
          TError,
          Awaited<ReturnType<typeof getExerciseContainersExercisesExerciseIdContainersGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExerciseContainersExercisesExerciseIdContainersGet<TData = Awaited<ReturnType<typeof getExerciseContainersExercisesExerciseIdContainersGet>>, TError = HTTPValidationError>(
 exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExerciseContainersExercisesExerciseIdContainersGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Exercise Containers
 */

export function useGetExerciseContainersExercisesExerciseIdContainersGet<TData = Awaited<ReturnType<typeof getExerciseContainersExercisesExerciseIdContainersGet>>, TError = HTTPValidationError>(
 exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExerciseContainersExercisesExerciseIdContainersGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetExerciseContainersExercisesExerciseIdContainersGetQueryOptions(exerciseId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 流式获取练习构建日志
 * @summary Stream Exercise Build Logs
 */
export const streamExerciseBuildLogsLogsStreamExerciseExerciseIdBuildGet = (
    exerciseId: string,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<unknown>(
      {url: `/logs/stream/exercise/${exerciseId}/build`, method: 'GET', signal
    },
      );
    }
  

export const getStreamExerciseBuildLogsLogsStreamExerciseExerciseIdBuildGetQueryKey = (exerciseId: string,) => {
    return [`/logs/stream/exercise/${exerciseId}/build`] as const;
    }

    
export const getStreamExerciseBuildLogsLogsStreamExerciseExerciseIdBuildGetQueryOptions = <TData = Awaited<ReturnType<typeof streamExerciseBuildLogsLogsStreamExerciseExerciseIdBuildGet>>, TError = HTTPValidationError>(exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamExerciseBuildLogsLogsStreamExerciseExerciseIdBuildGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStreamExerciseBuildLogsLogsStreamExerciseExerciseIdBuildGetQueryKey(exerciseId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof streamExerciseBuildLogsLogsStreamExerciseExerciseIdBuildGet>>> = ({ signal }) => streamExerciseBuildLogsLogsStreamExerciseExerciseIdBuildGet(exerciseId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(exerciseId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof streamExerciseBuildLogsLogsStreamExerciseExerciseIdBuildGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StreamExerciseBuildLogsLogsStreamExerciseExerciseIdBuildGetQueryResult = NonNullable<Awaited<ReturnType<typeof streamExerciseBuildLogsLogsStreamExerciseExerciseIdBuildGet>>>
export type StreamExerciseBuildLogsLogsStreamExerciseExerciseIdBuildGetQueryError = HTTPValidationError


export function useStreamExerciseBuildLogsLogsStreamExerciseExerciseIdBuildGet<TData = Awaited<ReturnType<typeof streamExerciseBuildLogsLogsStreamExerciseExerciseIdBuildGet>>, TError = HTTPValidationError>(
 exerciseId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamExerciseBuildLogsLogsStreamExerciseExerciseIdBuildGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamExerciseBuildLogsLogsStreamExerciseExerciseIdBuildGet>>,
          TError,
          Awaited<ReturnType<typeof streamExerciseBuildLogsLogsStreamExerciseExerciseIdBuildGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStreamExerciseBuildLogsLogsStreamExerciseExerciseIdBuildGet<TData = Awaited<ReturnType<typeof streamExerciseBuildLogsLogsStreamExerciseExerciseIdBuildGet>>, TError = HTTPValidationError>(
 exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamExerciseBuildLogsLogsStreamExerciseExerciseIdBuildGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamExerciseBuildLogsLogsStreamExerciseExerciseIdBuildGet>>,
          TError,
          Awaited<ReturnType<typeof streamExerciseBuildLogsLogsStreamExerciseExerciseIdBuildGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStreamExerciseBuildLogsLogsStreamExerciseExerciseIdBuildGet<TData = Awaited<ReturnType<typeof streamExerciseBuildLogsLogsStreamExerciseExerciseIdBuildGet>>, TError = HTTPValidationError>(
 exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamExerciseBuildLogsLogsStreamExerciseExerciseIdBuildGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Stream Exercise Build Logs
 */

export function useStreamExerciseBuildLogsLogsStreamExerciseExerciseIdBuildGet<TData = Awaited<ReturnType<typeof streamExerciseBuildLogsLogsStreamExerciseExerciseIdBuildGet>>, TError = HTTPValidationError>(
 exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamExerciseBuildLogsLogsStreamExerciseExerciseIdBuildGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStreamExerciseBuildLogsLogsStreamExerciseExerciseIdBuildGetQueryOptions(exerciseId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 流式获取练习容器日志
 * @summary Stream Exercise Container Logs
 */
export const streamExerciseContainerLogsLogsStreamExerciseExerciseIdContainerGet = (
    exerciseId: string,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<unknown>(
      {url: `/logs/stream/exercise/${exerciseId}/container`, method: 'GET', signal
    },
      );
    }
  

export const getStreamExerciseContainerLogsLogsStreamExerciseExerciseIdContainerGetQueryKey = (exerciseId: string,) => {
    return [`/logs/stream/exercise/${exerciseId}/container`] as const;
    }

    
export const getStreamExerciseContainerLogsLogsStreamExerciseExerciseIdContainerGetQueryOptions = <TData = Awaited<ReturnType<typeof streamExerciseContainerLogsLogsStreamExerciseExerciseIdContainerGet>>, TError = HTTPValidationError>(exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamExerciseContainerLogsLogsStreamExerciseExerciseIdContainerGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStreamExerciseContainerLogsLogsStreamExerciseExerciseIdContainerGetQueryKey(exerciseId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof streamExerciseContainerLogsLogsStreamExerciseExerciseIdContainerGet>>> = ({ signal }) => streamExerciseContainerLogsLogsStreamExerciseExerciseIdContainerGet(exerciseId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(exerciseId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof streamExerciseContainerLogsLogsStreamExerciseExerciseIdContainerGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StreamExerciseContainerLogsLogsStreamExerciseExerciseIdContainerGetQueryResult = NonNullable<Awaited<ReturnType<typeof streamExerciseContainerLogsLogsStreamExerciseExerciseIdContainerGet>>>
export type StreamExerciseContainerLogsLogsStreamExerciseExerciseIdContainerGetQueryError = HTTPValidationError


export function useStreamExerciseContainerLogsLogsStreamExerciseExerciseIdContainerGet<TData = Awaited<ReturnType<typeof streamExerciseContainerLogsLogsStreamExerciseExerciseIdContainerGet>>, TError = HTTPValidationError>(
 exerciseId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamExerciseContainerLogsLogsStreamExerciseExerciseIdContainerGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamExerciseContainerLogsLogsStreamExerciseExerciseIdContainerGet>>,
          TError,
          Awaited<ReturnType<typeof streamExerciseContainerLogsLogsStreamExerciseExerciseIdContainerGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStreamExerciseContainerLogsLogsStreamExerciseExerciseIdContainerGet<TData = Awaited<ReturnType<typeof streamExerciseContainerLogsLogsStreamExerciseExerciseIdContainerGet>>, TError = HTTPValidationError>(
 exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamExerciseContainerLogsLogsStreamExerciseExerciseIdContainerGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamExerciseContainerLogsLogsStreamExerciseExerciseIdContainerGet>>,
          TError,
          Awaited<ReturnType<typeof streamExerciseContainerLogsLogsStreamExerciseExerciseIdContainerGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStreamExerciseContainerLogsLogsStreamExerciseExerciseIdContainerGet<TData = Awaited<ReturnType<typeof streamExerciseContainerLogsLogsStreamExerciseExerciseIdContainerGet>>, TError = HTTPValidationError>(
 exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamExerciseContainerLogsLogsStreamExerciseExerciseIdContainerGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Stream Exercise Container Logs
 */

export function useStreamExerciseContainerLogsLogsStreamExerciseExerciseIdContainerGet<TData = Awaited<ReturnType<typeof streamExerciseContainerLogsLogsStreamExerciseExerciseIdContainerGet>>, TError = HTTPValidationError>(
 exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamExerciseContainerLogsLogsStreamExerciseExerciseIdContainerGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStreamExerciseContainerLogsLogsStreamExerciseExerciseIdContainerGetQueryOptions(exerciseId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 流式获取练习日志
 * @summary Stream Exercise Logs
 */
export const streamExerciseLogsLogsStreamExerciseExerciseIdGet = (
    exerciseId: string,
 signal?: AbortSignal
) => {
      
      
      return docker_manager_api<unknown>(
      {url: `/logs/stream/exercise/${exerciseId}`, method: 'GET', signal
    },
      );
    }
  

export const getStreamExerciseLogsLogsStreamExerciseExerciseIdGetQueryKey = (exerciseId: string,) => {
    return [`/logs/stream/exercise/${exerciseId}`] as const;
    }

    
export const getStreamExerciseLogsLogsStreamExerciseExerciseIdGetQueryOptions = <TData = Awaited<ReturnType<typeof streamExerciseLogsLogsStreamExerciseExerciseIdGet>>, TError = HTTPValidationError>(exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamExerciseLogsLogsStreamExerciseExerciseIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStreamExerciseLogsLogsStreamExerciseExerciseIdGetQueryKey(exerciseId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof streamExerciseLogsLogsStreamExerciseExerciseIdGet>>> = ({ signal }) => streamExerciseLogsLogsStreamExerciseExerciseIdGet(exerciseId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(exerciseId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof streamExerciseLogsLogsStreamExerciseExerciseIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StreamExerciseLogsLogsStreamExerciseExerciseIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof streamExerciseLogsLogsStreamExerciseExerciseIdGet>>>
export type StreamExerciseLogsLogsStreamExerciseExerciseIdGetQueryError = HTTPValidationError


export function useStreamExerciseLogsLogsStreamExerciseExerciseIdGet<TData = Awaited<ReturnType<typeof streamExerciseLogsLogsStreamExerciseExerciseIdGet>>, TError = HTTPValidationError>(
 exerciseId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamExerciseLogsLogsStreamExerciseExerciseIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamExerciseLogsLogsStreamExerciseExerciseIdGet>>,
          TError,
          Awaited<ReturnType<typeof streamExerciseLogsLogsStreamExerciseExerciseIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStreamExerciseLogsLogsStreamExerciseExerciseIdGet<TData = Awaited<ReturnType<typeof streamExerciseLogsLogsStreamExerciseExerciseIdGet>>, TError = HTTPValidationError>(
 exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamExerciseLogsLogsStreamExerciseExerciseIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamExerciseLogsLogsStreamExerciseExerciseIdGet>>,
          TError,
          Awaited<ReturnType<typeof streamExerciseLogsLogsStreamExerciseExerciseIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStreamExerciseLogsLogsStreamExerciseExerciseIdGet<TData = Awaited<ReturnType<typeof streamExerciseLogsLogsStreamExerciseExerciseIdGet>>, TError = HTTPValidationError>(
 exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamExerciseLogsLogsStreamExerciseExerciseIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Stream Exercise Logs
 */

export function useStreamExerciseLogsLogsStreamExerciseExerciseIdGet<TData = Awaited<ReturnType<typeof streamExerciseLogsLogsStreamExerciseExerciseIdGet>>, TError = HTTPValidationError>(
 exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamExerciseLogsLogsStreamExerciseExerciseIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStreamExerciseLogsLogsStreamExerciseExerciseIdGetQueryOptions(exerciseId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
