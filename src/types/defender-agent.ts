/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * Defender Agent API
 * ÁΩëÁªúÂÆâÂÖ®Èò≤Âæ°‰ª£ÁêÜAPI
 * OpenAPI spec version: 2.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { defender_agent_api } from '../utils/defender-agent-api';
/**
 * ÂìçÂ∫îÊï∞ÊçÆ
 */
export type ApiResponseDefenseReportResponseData = DefenseReportResponse | null;

export interface ApiResponseDefenseReportResponse {
  /** ‰∏öÂä°Áä∂ÊÄÅÁ†ÅÔºåÈùûHTTPÁä∂ÊÄÅÁ†Å */
  code?: number;
  /** ÂìçÂ∫îÊ∂àÊÅØ */
  message?: string;
  /** ÂìçÂ∫îÊï∞ÊçÆ */
  data?: ApiResponseDefenseReportResponseData;
}

/**
 * ÂìçÂ∫îÊï∞ÊçÆ
 */
export type ApiResponseInstanceCleanupResponseData = InstanceCleanupResponse | null;

export interface ApiResponseInstanceCleanupResponse {
  /** ‰∏öÂä°Áä∂ÊÄÅÁ†ÅÔºåÈùûHTTPÁä∂ÊÄÅÁ†Å */
  code?: number;
  /** ÂìçÂ∫îÊ∂àÊÅØ */
  message?: string;
  /** ÂìçÂ∫îÊï∞ÊçÆ */
  data?: ApiResponseInstanceCleanupResponseData;
}

/**
 * ÂìçÂ∫îÊï∞ÊçÆ
 */
export type ApiResponseInstanceInitResponseData = InstanceInitResponse | null;

export interface ApiResponseInstanceInitResponse {
  /** ‰∏öÂä°Áä∂ÊÄÅÁ†ÅÔºåÈùûHTTPÁä∂ÊÄÅÁ†Å */
  code?: number;
  /** ÂìçÂ∫îÊ∂àÊÅØ */
  message?: string;
  /** ÂìçÂ∫îÊï∞ÊçÆ */
  data?: ApiResponseInstanceInitResponseData;
}

/**
 * ÂìçÂ∫îÊï∞ÊçÆ
 */
export type ApiResponseInstanceStatusResponseData = InstanceStatusResponse | null;

export interface ApiResponseInstanceStatusResponse {
  /** ‰∏öÂä°Áä∂ÊÄÅÁ†ÅÔºåÈùûHTTPÁä∂ÊÄÅÁ†Å */
  code?: number;
  /** ÂìçÂ∫îÊ∂àÊÅØ */
  message?: string;
  /** ÂìçÂ∫îÊï∞ÊçÆ */
  data?: ApiResponseInstanceStatusResponseData;
}

/**
 * ÊîªÂáªÈìæÂàÜÊûê
 */
export interface AttackChainAnalysis {
  /** ÊîªÂáªÈò∂ÊÆµÂàóË°® */
  attack_stages: string[];
  /** ÊîªÂáªË∑ØÂæÑÊèèËø∞ */
  attack_path: string;
  /** ÊîªÂáªÊäÄÊúØÂàóË°® */
  attack_techniques: string[];
}

/**
 * ÊîªÂáªÁ±ªÂûã
 */
export interface AttackType {
  /** ÊîªÂáªÁ±ªÂûãÊèèËø∞ */
  description: string;
  /** ÊîªÂáªÁ§∫‰æãÂàóË°® */
  examples: string[];
}

/**
 * Ê∫ØÊ∫êÁªìËÆ∫ÊëòË¶Å
 */
export interface AttributionSummary {
  /** ÊîªÂáªËÄÖÂΩíÂ±û */
  attacker_attribution: string;
  /** ÊîªÂáªÂä®Êú∫ */
  attack_motivation: string;
  /** ÊîªÂáªÂΩ±Âìç */
  attack_impact: string;
  /** Ê∫ØÊ∫êÁΩÆ‰ø°Â∫¶ */
  attribution_confidence: string;
  /** Ê∫ØÊ∫êÊé®ÁêÜËøáÁ®ã */
  attribution_reasoning: string;
}

export interface DefenseReportRequest {
  /** Èò≤Âæ°‰ª£ÁêÜÂÆû‰æãID */
  model_id: string;
}

/**
 * Êñá‰ª∂Â§ßÂ∞è(Â≠óËäÇ)
 */
export type DefenseReportResponseFileSize = number | null;

/**
 * Êñá‰ª∂ÊúÄÂêé‰øÆÊîπÊó∂Èó¥
 */
export type DefenseReportResponseLastModified = string | null;

export interface DefenseReportResponse {
  /** Èò≤Âæ°‰ª£ÁêÜÂÆû‰æãID */
  model_id: string;
  /** Êä•ÂëäÊñá‰ª∂Ë∑ØÂæÑ */
  report_file: string;
  /** Êä•ÂëäÊï∞ÊçÆ */
  report_data: DefenseReportSchema;
  /** Ëé∑ÂèñÊó∂Èó¥ */
  timestamp: string;
  /** Êñá‰ª∂Â§ßÂ∞è(Â≠óËäÇ) */
  file_size?: DefenseReportResponseFileSize;
  /** Êñá‰ª∂ÊúÄÂêé‰øÆÊîπÊó∂Èó¥ */
  last_modified?: DefenseReportResponseLastModified;
}

/**
 * ÊâßË°åÊëòË¶Å
 */
export type DefenseReportSchemaExecutiveSummary = ExecutiveSummary | string | null;

/**
 * Â®ÅËÉÅÁªüËÆ°
 */
export type DefenseReportSchemaThreatStatistics = ThreatStatistics | string | null;

export type DefenseReportSchemaAttackTypesAnyOf = {[key: string]: AttackType};

/**
 * ÊîªÂáªÁ±ªÂûãÂàÜÊûê
 */
export type DefenseReportSchemaAttackTypes = DefenseReportSchemaAttackTypesAnyOf | string | null;

/**
 * Â®ÅËÉÅÈòªÊñ≠ÂàÜÊûê
 */
export type DefenseReportSchemaThreatBlockingAnalysis = ThreatBlockingAnalysis | string | null;

/**
 * ÊºèÊ¥û‰øÆÂ§çÂàÜÊûê
 */
export type DefenseReportSchemaVulnerabilityRemediationAnalysis = VulnerabilityRemediationAnalysis | string | null;

/**
 * Ê∫ØÊ∫êÁªìËÆ∫ÊëòË¶Å
 */
export type DefenseReportSchemaAttributionSummary = AttributionSummary | string | null;

/**
 * ÊîªÂáªÈìæÂàÜÊûê
 */
export type DefenseReportSchemaAttackChainAnalysis = AttackChainAnalysis | string | null;

/**
 * ÂìçÂ∫îÊïàÊûúËØÑ‰º∞
 */
export type DefenseReportSchemaResponseEffectiveness = ResponseEffectiveness | string | null;

/**
 * Â∫îÊÄ•ÂìçÂ∫îÈ¢ÑÊ°à
 */
export type DefenseReportSchemaEmergencyResponsePlan = EmergencyResponsePlan | string | null;

/**
 * ÂÆâÂÖ®ÊîπËøõÂª∫ËÆÆ
 */
export type DefenseReportSchemaSecurityRecommendations = SecurityRecommendations | string | null;

/**
 * È£éÈô©ËØÑ‰º∞
 */
export type DefenseReportSchemaRiskAssessment = RiskAssessment | string | null;

/**
 * ÂêéÁª≠Ë°åÂä®Âª∫ËÆÆ
 */
export type DefenseReportSchemaNextSteps = NextSteps | string | null;

/**
 * Èò≤Âæ°Êä•ÂëäÂÆåÊï¥ÁªìÊûÑ - ÈÄÇÈÖçAIÁîüÊàêÁöÑÊ†ºÂºè
 */
export interface DefenseReportSchema {
  /** ÊâßË°åÊëòË¶Å */
  executive_summary?: DefenseReportSchemaExecutiveSummary;
  /** Â®ÅËÉÅÁªüËÆ° */
  threat_statistics?: DefenseReportSchemaThreatStatistics;
  /** ÊîªÂáªÁ±ªÂûãÂàÜÊûê */
  attack_types?: DefenseReportSchemaAttackTypes;
  /** Â®ÅËÉÅÈòªÊñ≠ÂàÜÊûê */
  threat_blocking_analysis?: DefenseReportSchemaThreatBlockingAnalysis;
  /** ÊºèÊ¥û‰øÆÂ§çÂàÜÊûê */
  vulnerability_remediation_analysis?: DefenseReportSchemaVulnerabilityRemediationAnalysis;
  /** Ê∫ØÊ∫êÁªìËÆ∫ÊëòË¶Å */
  attribution_summary?: DefenseReportSchemaAttributionSummary;
  /** ÊîªÂáªÈìæÂàÜÊûê */
  attack_chain_analysis?: DefenseReportSchemaAttackChainAnalysis;
  /** ÂìçÂ∫îÊïàÊûúËØÑ‰º∞ */
  response_effectiveness?: DefenseReportSchemaResponseEffectiveness;
  /** Â∫îÊÄ•ÂìçÂ∫îÈ¢ÑÊ°à */
  emergency_response_plan?: DefenseReportSchemaEmergencyResponsePlan;
  /** ÂÆâÂÖ®ÊîπËøõÂª∫ËÆÆ */
  security_recommendations?: DefenseReportSchemaSecurityRecommendations;
  /** È£éÈô©ËØÑ‰º∞ */
  risk_assessment?: DefenseReportSchemaRiskAssessment;
  /** ÂêéÁª≠Ë°åÂä®Âª∫ËÆÆ */
  next_steps?: DefenseReportSchemaNextSteps;
}

/**
 * Â∫îÊÄ•ÂìçÂ∫îÈ¢ÑÊ°à
 */
export interface EmergencyResponsePlan {
  /** Á´ãÂç≥Ë°åÂä®ÂàóË°® */
  immediate_actions: string[];
  /** Áü≠ÊúüÊé™ÊñΩÂàóË°® */
  short_term_measures: string[];
  /** ÈïøÊúüÊîπËøõÂàóË°® */
  long_term_improvements: string[];
  /** ‰∫∫ÂëòÂàÜÂ∑•ÂàóË°® */
  personnel_assignments: string[];
  /** Ê≤üÈÄöÊú∫Âà∂ÂàóË°® */
  communication_mechanisms: string[];
}

/**
 * ÊâßË°åÊëòË¶Å
 */
export interface ExecutiveSummary {
  /** Â®ÅËÉÅÊ¶ÇÂÜµÊèèËø∞ */
  threat_overview: string;
  /** ‰∏ªË¶ÅÂèëÁé∞ÂàóË°® */
  main_findings: string[];
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export interface InstanceCleanupResponse {
  /** Èò≤Âæ°‰ª£ÁêÜÂÆû‰æãID */
  model_id: string;
  /** Ê∏ÖÁêÜÁä∂ÊÄÅ */
  status: string;
  /** Ê∏ÖÁêÜÊó∂Èó¥ */
  cleaned_at: string;
}

/**
 * ÂÆû‰æãÈÖçÁΩÆ‰ø°ÊÅØ
 */
export interface InstanceConfig {
  /** Ê®°ÂûãÂêçÁß∞ */
  model_name: string;
  /** ‰ºöËØùID */
  session_id: string;
  /** Êó•ÂøóÁ∫ßÂà´ */
  log_level: string;
  /** ÊúÄÂ§ßËøûÊé•Êï∞ */
  max_connections: number;
  /** Ë∂ÖÊó∂Êó∂Èó¥(Áßí) */
  timeout: number;
}

export interface InstanceInitRequest {
  /** Èò≤Âæ°‰ª£ÁêÜÂÆû‰æãID */
  model_id: string;
}

export interface InstanceInitResponse {
  /** Èò≤Âæ°‰ª£ÁêÜÂÆû‰æãID */
  model_id: string;
  /** ÂÆû‰æãÁä∂ÊÄÅ */
  status: string;
  /** ÂàõÂª∫Êó∂Èó¥ */
  created_at: string;
}

/**
 * ÊúÄÂêéÊ¥ªÂä®Êó∂Èó¥
 */
export type InstanceStatusResponseLastActivity = string | null;

/**
 * ÈÖçÁΩÆ‰ø°ÊÅØ
 */
export type InstanceStatusResponseConfigInfo = InstanceConfig | null;

export interface InstanceStatusResponse {
  /** Èò≤Âæ°‰ª£ÁêÜÂÆû‰æãID */
  model_id: string;
  /** ÊòØÂê¶Â∑≤ÂàùÂßãÂåñ */
  initialized: boolean;
  /** ÊúÄÂêéÊ¥ªÂä®Êó∂Èó¥ */
  last_activity?: InstanceStatusResponseLastActivity;
  /** ÈÖçÁΩÆ‰ø°ÊÅØ */
  config_info?: InstanceStatusResponseConfigInfo;
}

export interface LogStreamRequest {
  /** Èò≤Âæ°‰ª£ÁêÜÂÆû‰æãID */
  model_id: string;
}

/**
 * ÂêéÁª≠Ë°åÂä®Âª∫ËÆÆ
 */
export interface NextSteps {
  /** Ë°åÂä®Ê≠•È™§ÂàóË°® */
  steps: string[];
}

/**
 * ÂìçÂ∫îÊïàÊûúËØÑ‰º∞
 */
export interface ResponseEffectiveness {
  /** ÊïàÊûúËØÑÁ∫ß */
  effectiveness: string;
  /** ËØ¶ÁªÜËØ¥Êòé */
  details: string;
}

/**
 * È£éÈô©ËØÑ‰º∞
 */
export interface RiskAssessment {
  /** È£éÈô©Á≠âÁ∫ß */
  risk_level: string;
  /** È£éÈô©ËØ¶ÊÉÖ */
  details: string;
}

/**
 * ÂÆâÂÖ®ÊîπËøõÂª∫ËÆÆ
 */
export interface SecurityRecommendations {
  /** Âª∫ËÆÆÂàóË°® */
  recommendations: string[];
}

/**
 * Â®ÅËÉÅÈòªÊñ≠ÂàÜÊûê
 */
export interface ThreatBlockingAnalysis {
  /** ÈòªÊñ≠ÁöÑIPÂàóË°® */
  blocked_ips: string[];
  /** ÈòªÊñ≠ÁöÑÁ´ØÂè£ÂàóË°® */
  blocked_ports: string[];
  /** Èò≤ÁÅ´Â¢ôËßÑÂàôÂàóË°® */
  firewall_rules: string[];
  /** ÈòªÊñ≠ÊïàÊûúËØÑ‰º∞ */
  blocking_effectiveness: string;
}

/**
 * ÊåâÁ±ªÂûãÂàÜÂ∏É
 */
export type ThreatStatisticsTypeDistribution = {[key: string]: number};

/**
 * Êåâ‰∏•ÈáçÁ®ãÂ∫¶ÂàÜÂ∏É
 */
export type ThreatStatisticsSeverityDistribution = {[key: string]: number};

/**
 * Â®ÅËÉÅÁªüËÆ°
 */
export interface ThreatStatistics {
  /** ÊÄªÂ®ÅËÉÅÊï∞ */
  total_threats: number;
  /** ÊåâÁ±ªÂûãÂàÜÂ∏É */
  type_distribution: ThreatStatisticsTypeDistribution;
  /** Êåâ‰∏•ÈáçÁ®ãÂ∫¶ÂàÜÂ∏É */
  severity_distribution: ThreatStatisticsSeverityDistribution;
}

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

/**
 * ÊºèÊ¥û‰øÆÂ§çÂàÜÊûê
 */
export interface VulnerabilityRemediationAnalysis {
  /** ÈáçÂêØÁöÑÊúçÂä°ÂàóË°® */
  restarted_services: string[];
  /** WebÈÖçÁΩÆ‰øÆÊîπÂàóË°® */
  web_config_changes: string[];
  /** Â∫îÁî®ÁöÑË°•‰∏ÅÂàóË°® */
  applied_patches: string[];
  /** ‰øÆÂ§çÊàêÂäüÁéá */
  remediation_success_rate: string;
  /** ‰øÆÂ§çÂä®‰ΩúÂàóË°® */
  remediation_actions: string[];
}

export type StreamLogsApiLogsStreamPost404 = {
  code?: number;
  message?: string;
  data?: null;
};

export type StreamLogsApiLogsStreamPost500 = {
  code?: number;
  message?: string;
  data?: null;
};

/**
 * ‰ΩøÁî®SSEÂçèËÆÆÊµÅÂºèËé∑ÂèñÊåáÂÆömodel_idÁöÑÁ≥ªÁªüÊó•ÂøóÔºåÊîØÊåÅÊ†áÂáÜ‰∫ã‰ª∂Á±ªÂûãÔºöstart„ÄÅping„ÄÅmessage„ÄÅend„ÄÅerror
 * @summary Ëé∑ÂèñÊó•ÂøóÊµÅÂºè‰º†Ëæì
 */
export const streamLogsApiLogsStreamPost = (
    logStreamRequest: LogStreamRequest,
 signal?: AbortSignal
) => {
      
      
      return defender_agent_api<unknown>(
      {url: `/api/logs/stream`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: logStreamRequest, signal
    },
      );
    }
  


export const getStreamLogsApiLogsStreamPostMutationOptions = <TError = StreamLogsApiLogsStreamPost404 | HTTPValidationError | StreamLogsApiLogsStreamPost500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof streamLogsApiLogsStreamPost>>, TError,{data: LogStreamRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof streamLogsApiLogsStreamPost>>, TError,{data: LogStreamRequest}, TContext> => {

const mutationKey = ['streamLogsApiLogsStreamPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof streamLogsApiLogsStreamPost>>, {data: LogStreamRequest}> = (props) => {
          const {data} = props ?? {};

          return  streamLogsApiLogsStreamPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type StreamLogsApiLogsStreamPostMutationResult = NonNullable<Awaited<ReturnType<typeof streamLogsApiLogsStreamPost>>>
    export type StreamLogsApiLogsStreamPostMutationBody = LogStreamRequest
    export type StreamLogsApiLogsStreamPostMutationError = StreamLogsApiLogsStreamPost404 | HTTPValidationError | StreamLogsApiLogsStreamPost500

    /**
 * @summary Ëé∑ÂèñÊó•ÂøóÊµÅÂºè‰º†Ëæì
 */
export const useStreamLogsApiLogsStreamPost = <TError = StreamLogsApiLogsStreamPost404 | HTTPValidationError | StreamLogsApiLogsStreamPost500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof streamLogsApiLogsStreamPost>>, TError,{data: LogStreamRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof streamLogsApiLogsStreamPost>>,
        TError,
        {data: LogStreamRequest},
        TContext
      > => {

      const mutationOptions = getStreamLogsApiLogsStreamPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Ëé∑ÂèñÊåáÂÆöÈò≤Âæ°‰ª£ÁêÜÂÆû‰æãÁöÑÈò≤Âæ°Êä•ÂëäÂÜÖÂÆπÔºåÂåÖÂê´ËØ¶ÁªÜÁöÑJSONÂÖÉÊï∞ÊçÆÁªìÊûÑ
 * @summary Ëé∑ÂèñÊåáÂÆömodel_idÁöÑÈò≤Âæ°Êä•Âëä
 */
export const getDefenseReportApiDefenseReportGetPost = (
    defenseReportRequest: DefenseReportRequest,
 signal?: AbortSignal
) => {
      
      
      return defender_agent_api<ApiResponseDefenseReportResponse>(
      {url: `/api/defense-report/get`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: defenseReportRequest, signal
    },
      );
    }
  


export const getGetDefenseReportApiDefenseReportGetPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getDefenseReportApiDefenseReportGetPost>>, TError,{data: DefenseReportRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof getDefenseReportApiDefenseReportGetPost>>, TError,{data: DefenseReportRequest}, TContext> => {

const mutationKey = ['getDefenseReportApiDefenseReportGetPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getDefenseReportApiDefenseReportGetPost>>, {data: DefenseReportRequest}> = (props) => {
          const {data} = props ?? {};

          return  getDefenseReportApiDefenseReportGetPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetDefenseReportApiDefenseReportGetPostMutationResult = NonNullable<Awaited<ReturnType<typeof getDefenseReportApiDefenseReportGetPost>>>
    export type GetDefenseReportApiDefenseReportGetPostMutationBody = DefenseReportRequest
    export type GetDefenseReportApiDefenseReportGetPostMutationError = HTTPValidationError

    /**
 * @summary Ëé∑ÂèñÊåáÂÆömodel_idÁöÑÈò≤Âæ°Êä•Âëä
 */
export const useGetDefenseReportApiDefenseReportGetPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getDefenseReportApiDefenseReportGetPost>>, TError,{data: DefenseReportRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof getDefenseReportApiDefenseReportGetPost>>,
        TError,
        {data: DefenseReportRequest},
        TContext
      > => {

      const mutationOptions = getGetDefenseReportApiDefenseReportGetPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * ÂàõÂª∫Âπ∂ÂàùÂßãÂåñÊåáÂÆömodel_idÁöÑÈò≤Âæ°‰ª£ÁêÜÂÆû‰æã
 * @summary ÂàùÂßãÂåñÈò≤Âæ°‰ª£ÁêÜÂÆû‰æã
 */
export const initDefenderInstanceApiInstanceInitPost = (
    instanceInitRequest: InstanceInitRequest,
 signal?: AbortSignal
) => {
      
      
      return defender_agent_api<ApiResponseInstanceInitResponse>(
      {url: `/api/instance/init`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: instanceInitRequest, signal
    },
      );
    }
  


export const getInitDefenderInstanceApiInstanceInitPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initDefenderInstanceApiInstanceInitPost>>, TError,{data: InstanceInitRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof initDefenderInstanceApiInstanceInitPost>>, TError,{data: InstanceInitRequest}, TContext> => {

const mutationKey = ['initDefenderInstanceApiInstanceInitPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof initDefenderInstanceApiInstanceInitPost>>, {data: InstanceInitRequest}> = (props) => {
          const {data} = props ?? {};

          return  initDefenderInstanceApiInstanceInitPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InitDefenderInstanceApiInstanceInitPostMutationResult = NonNullable<Awaited<ReturnType<typeof initDefenderInstanceApiInstanceInitPost>>>
    export type InitDefenderInstanceApiInstanceInitPostMutationBody = InstanceInitRequest
    export type InitDefenderInstanceApiInstanceInitPostMutationError = HTTPValidationError

    /**
 * @summary ÂàùÂßãÂåñÈò≤Âæ°‰ª£ÁêÜÂÆû‰æã
 */
export const useInitDefenderInstanceApiInstanceInitPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initDefenderInstanceApiInstanceInitPost>>, TError,{data: InstanceInitRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof initDefenderInstanceApiInstanceInitPost>>,
        TError,
        {data: InstanceInitRequest},
        TContext
      > => {

      const mutationOptions = getInitDefenderInstanceApiInstanceInitPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Ëé∑ÂèñÊåáÂÆömodel_idÁöÑÈò≤Âæ°‰ª£ÁêÜÂÆû‰æãÂΩìÂâçÁä∂ÊÄÅ‰ø°ÊÅØ
 * @summary Ëé∑ÂèñÈò≤Âæ°‰ª£ÁêÜÂÆû‰æãÁä∂ÊÄÅ
 */
export const getInstanceStatusApiInstanceStatusModelIdGet = (
    modelId: string,
 signal?: AbortSignal
) => {
      
      
      return defender_agent_api<ApiResponseInstanceStatusResponse>(
      {url: `/api/instance/status/${modelId}`, method: 'GET', signal
    },
      );
    }
  

export const getGetInstanceStatusApiInstanceStatusModelIdGetQueryKey = (modelId: string,) => {
    return [`/api/instance/status/${modelId}`] as const;
    }

    
export const getGetInstanceStatusApiInstanceStatusModelIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getInstanceStatusApiInstanceStatusModelIdGet>>, TError = HTTPValidationError>(modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInstanceStatusApiInstanceStatusModelIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetInstanceStatusApiInstanceStatusModelIdGetQueryKey(modelId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getInstanceStatusApiInstanceStatusModelIdGet>>> = ({ signal }) => getInstanceStatusApiInstanceStatusModelIdGet(modelId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(modelId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getInstanceStatusApiInstanceStatusModelIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetInstanceStatusApiInstanceStatusModelIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getInstanceStatusApiInstanceStatusModelIdGet>>>
export type GetInstanceStatusApiInstanceStatusModelIdGetQueryError = HTTPValidationError


export function useGetInstanceStatusApiInstanceStatusModelIdGet<TData = Awaited<ReturnType<typeof getInstanceStatusApiInstanceStatusModelIdGet>>, TError = HTTPValidationError>(
 modelId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInstanceStatusApiInstanceStatusModelIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInstanceStatusApiInstanceStatusModelIdGet>>,
          TError,
          Awaited<ReturnType<typeof getInstanceStatusApiInstanceStatusModelIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInstanceStatusApiInstanceStatusModelIdGet<TData = Awaited<ReturnType<typeof getInstanceStatusApiInstanceStatusModelIdGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInstanceStatusApiInstanceStatusModelIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInstanceStatusApiInstanceStatusModelIdGet>>,
          TError,
          Awaited<ReturnType<typeof getInstanceStatusApiInstanceStatusModelIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInstanceStatusApiInstanceStatusModelIdGet<TData = Awaited<ReturnType<typeof getInstanceStatusApiInstanceStatusModelIdGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInstanceStatusApiInstanceStatusModelIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Ëé∑ÂèñÈò≤Âæ°‰ª£ÁêÜÂÆû‰æãÁä∂ÊÄÅ
 */

export function useGetInstanceStatusApiInstanceStatusModelIdGet<TData = Awaited<ReturnType<typeof getInstanceStatusApiInstanceStatusModelIdGet>>, TError = HTTPValidationError>(
 modelId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInstanceStatusApiInstanceStatusModelIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetInstanceStatusApiInstanceStatusModelIdGetQueryOptions(modelId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Ê∏ÖÁêÜÂπ∂ÈáäÊîæÊåáÂÆömodel_idÁöÑÈò≤Âæ°‰ª£ÁêÜÂÆû‰æãËµÑÊ∫ê
 * @summary Ê∏ÖÁêÜÈò≤Âæ°‰ª£ÁêÜÂÆû‰æã
 */
export const cleanupDefenderInstanceApiInstanceCleanupModelIdDelete = (
    modelId: string,
 ) => {
      
      
      return defender_agent_api<ApiResponseInstanceCleanupResponse>(
      {url: `/api/instance/cleanup/${modelId}`, method: 'DELETE'
    },
      );
    }
  


export const getCleanupDefenderInstanceApiInstanceCleanupModelIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cleanupDefenderInstanceApiInstanceCleanupModelIdDelete>>, TError,{modelId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof cleanupDefenderInstanceApiInstanceCleanupModelIdDelete>>, TError,{modelId: string}, TContext> => {

const mutationKey = ['cleanupDefenderInstanceApiInstanceCleanupModelIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cleanupDefenderInstanceApiInstanceCleanupModelIdDelete>>, {modelId: string}> = (props) => {
          const {modelId} = props ?? {};

          return  cleanupDefenderInstanceApiInstanceCleanupModelIdDelete(modelId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CleanupDefenderInstanceApiInstanceCleanupModelIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof cleanupDefenderInstanceApiInstanceCleanupModelIdDelete>>>
    
    export type CleanupDefenderInstanceApiInstanceCleanupModelIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Ê∏ÖÁêÜÈò≤Âæ°‰ª£ÁêÜÂÆû‰æã
 */
export const useCleanupDefenderInstanceApiInstanceCleanupModelIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cleanupDefenderInstanceApiInstanceCleanupModelIdDelete>>, TError,{modelId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof cleanupDefenderInstanceApiInstanceCleanupModelIdDelete>>,
        TError,
        {modelId: string},
        TContext
      > => {

      const mutationOptions = getCleanupDefenderInstanceApiInstanceCleanupModelIdDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Ê†πË∑ØÂæÑ
 * @summary Root
 */
export const rootGet = (
    
 signal?: AbortSignal
) => {
      
      
      return defender_agent_api<unknown>(
      {url: `/`, method: 'GET', signal
    },
      );
    }
  

export const getRootGetQueryKey = () => {
    return [`/`] as const;
    }

    
export const getRootGetQueryOptions = <TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRootGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof rootGet>>> = ({ signal }) => rootGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type RootGetQueryResult = NonNullable<Awaited<ReturnType<typeof rootGet>>>
export type RootGetQueryError = unknown


export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof rootGet>>,
          TError,
          Awaited<ReturnType<typeof rootGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof rootGet>>,
          TError,
          Awaited<ReturnType<typeof rootGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Root
 */

export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getRootGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ÂÅ•Â∫∑Ê£ÄÊü•
 * @summary Health
 */
export const healthHealthGet = (
    
 signal?: AbortSignal
) => {
      
      
      return defender_agent_api<unknown>(
      {url: `/health`, method: 'GET', signal
    },
      );
    }
  

export const getHealthHealthGetQueryKey = () => {
    return [`/health`] as const;
    }

    
export const getHealthHealthGetQueryOptions = <TData = Awaited<ReturnType<typeof healthHealthGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthHealthGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthHealthGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthHealthGet>>> = ({ signal }) => healthHealthGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof healthHealthGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthHealthGetQueryResult = NonNullable<Awaited<ReturnType<typeof healthHealthGet>>>
export type HealthHealthGetQueryError = unknown


export function useHealthHealthGet<TData = Awaited<ReturnType<typeof healthHealthGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthHealthGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthHealthGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthHealthGet<TData = Awaited<ReturnType<typeof healthHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthHealthGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthHealthGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthHealthGet<TData = Awaited<ReturnType<typeof healthHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthHealthGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Health
 */

export function useHealthHealthGet<TData = Awaited<ReturnType<typeof healthHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthHealthGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHealthHealthGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
