/**
 * Generated by orval v7.9.0 🍺
 * Do not edit manually.
 * Attack Monitor Backend API
 * 攻击监控系统后端API接口
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { backend_api } from '../utils/backend-api';
/**
 * 管理员创建用户时的请求模型
 */
export interface AdminUserCreate {
  username: string;
  password: string;
  roles?: number[];
}

export type AdminUserUpdateUsername = string | null;

export type AdminUserUpdatePassword = string | null;

export type AdminUserUpdateIsActive = boolean | null;

export type AdminUserUpdateRoles = number[] | null;

/**
 * 管理员更新用户时的请求模型
 */
export interface AdminUserUpdate {
  username?: AdminUserUpdateUsername;
  password?: AdminUserUpdatePassword;
  is_active?: AdminUserUpdateIsActive;
  roles?: AdminUserUpdateRoles;
}

export interface ChangePassword {
  old_password: string;
  new_password: string;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export interface LoginResponse {
  access_token: string;
  token_type: string;
  user: UserOut;
}

export type PermissionDescription = string | null;

export interface Permission {
  name: string;
  description?: PermissionDescription;
  id: number;
  created_time: string;
}

export type RoleDescription = string | null;

export interface Role {
  name: string;
  description?: RoleDescription;
  id: number;
  created_time: string;
  permissions?: Permission[];
}

export interface UserCreate {
  username: string;
  password: string;
}

export interface UserListResponse {
  users: UserOut[];
  total: number;
  skip: number;
  limit: number;
}

export interface UserLogin {
  username: string;
  password: string;
}

export interface UserOut {
  username: string;
  id: string;
  is_active: boolean;
  created_time: string;
  roles?: Role[];
}

export type UserUpdateUsername = string | null;

export interface UserUpdate {
  username?: UserUpdateUsername;
}

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export type GetAllUsersUsersAdminUsersGetParams = {
skip?: number;
limit?: number;
};

/**
 * @summary Register
 */
export const registerUsersRegisterPost = (
    userCreate: UserCreate,
 signal?: AbortSignal
) => {
      
      
      return backend_api<UserOut>(
      {url: `/users/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userCreate, signal
    },
      );
    }
  


export const getRegisterUsersRegisterPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerUsersRegisterPost>>, TError,{data: UserCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof registerUsersRegisterPost>>, TError,{data: UserCreate}, TContext> => {

const mutationKey = ['registerUsersRegisterPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registerUsersRegisterPost>>, {data: UserCreate}> = (props) => {
          const {data} = props ?? {};

          return  registerUsersRegisterPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterUsersRegisterPostMutationResult = NonNullable<Awaited<ReturnType<typeof registerUsersRegisterPost>>>
    export type RegisterUsersRegisterPostMutationBody = UserCreate
    export type RegisterUsersRegisterPostMutationError = HTTPValidationError

    /**
 * @summary Register
 */
export const useRegisterUsersRegisterPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerUsersRegisterPost>>, TError,{data: UserCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof registerUsersRegisterPost>>,
        TError,
        {data: UserCreate},
        TContext
      > => {

      const mutationOptions = getRegisterUsersRegisterPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Login
 */
export const loginUsersLoginPost = (
    userLogin: UserLogin,
 signal?: AbortSignal
) => {
      
      
      return backend_api<LoginResponse>(
      {url: `/users/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userLogin, signal
    },
      );
    }
  


export const getLoginUsersLoginPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginUsersLoginPost>>, TError,{data: UserLogin}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof loginUsersLoginPost>>, TError,{data: UserLogin}, TContext> => {

const mutationKey = ['loginUsersLoginPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginUsersLoginPost>>, {data: UserLogin}> = (props) => {
          const {data} = props ?? {};

          return  loginUsersLoginPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginUsersLoginPostMutationResult = NonNullable<Awaited<ReturnType<typeof loginUsersLoginPost>>>
    export type LoginUsersLoginPostMutationBody = UserLogin
    export type LoginUsersLoginPostMutationError = HTTPValidationError

    /**
 * @summary Login
 */
export const useLoginUsersLoginPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginUsersLoginPost>>, TError,{data: UserLogin}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof loginUsersLoginPost>>,
        TError,
        {data: UserLogin},
        TContext
      > => {

      const mutationOptions = getLoginUsersLoginPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 调试接口：检查token的状态，不进行用户验证
 * @summary Debug Token
 */
export const debugTokenUsersDebugTokenGet = (
    
 signal?: AbortSignal
) => {
      
      
      return backend_api<unknown>(
      {url: `/users/debug-token`, method: 'GET', signal
    },
      );
    }
  

export const getDebugTokenUsersDebugTokenGetQueryKey = () => {
    return [`/users/debug-token`] as const;
    }

    
export const getDebugTokenUsersDebugTokenGetQueryOptions = <TData = Awaited<ReturnType<typeof debugTokenUsersDebugTokenGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof debugTokenUsersDebugTokenGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDebugTokenUsersDebugTokenGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof debugTokenUsersDebugTokenGet>>> = ({ signal }) => debugTokenUsersDebugTokenGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof debugTokenUsersDebugTokenGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DebugTokenUsersDebugTokenGetQueryResult = NonNullable<Awaited<ReturnType<typeof debugTokenUsersDebugTokenGet>>>
export type DebugTokenUsersDebugTokenGetQueryError = unknown


export function useDebugTokenUsersDebugTokenGet<TData = Awaited<ReturnType<typeof debugTokenUsersDebugTokenGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof debugTokenUsersDebugTokenGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof debugTokenUsersDebugTokenGet>>,
          TError,
          Awaited<ReturnType<typeof debugTokenUsersDebugTokenGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDebugTokenUsersDebugTokenGet<TData = Awaited<ReturnType<typeof debugTokenUsersDebugTokenGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof debugTokenUsersDebugTokenGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof debugTokenUsersDebugTokenGet>>,
          TError,
          Awaited<ReturnType<typeof debugTokenUsersDebugTokenGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDebugTokenUsersDebugTokenGet<TData = Awaited<ReturnType<typeof debugTokenUsersDebugTokenGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof debugTokenUsersDebugTokenGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Debug Token
 */

export function useDebugTokenUsersDebugTokenGet<TData = Awaited<ReturnType<typeof debugTokenUsersDebugTokenGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof debugTokenUsersDebugTokenGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDebugTokenUsersDebugTokenGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 验证token是否有效，如果有效则返回当前用户信息
前端可以定期调用此接口来验证token状态
 * @summary Verify Token
 */
export const verifyTokenUsersVerifyTokenGet = (
    
 signal?: AbortSignal
) => {
      
      
      return backend_api<UserOut>(
      {url: `/users/verify-token`, method: 'GET', signal
    },
      );
    }
  

export const getVerifyTokenUsersVerifyTokenGetQueryKey = () => {
    return [`/users/verify-token`] as const;
    }

    
export const getVerifyTokenUsersVerifyTokenGetQueryOptions = <TData = Awaited<ReturnType<typeof verifyTokenUsersVerifyTokenGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof verifyTokenUsersVerifyTokenGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getVerifyTokenUsersVerifyTokenGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof verifyTokenUsersVerifyTokenGet>>> = ({ signal }) => verifyTokenUsersVerifyTokenGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof verifyTokenUsersVerifyTokenGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type VerifyTokenUsersVerifyTokenGetQueryResult = NonNullable<Awaited<ReturnType<typeof verifyTokenUsersVerifyTokenGet>>>
export type VerifyTokenUsersVerifyTokenGetQueryError = unknown


export function useVerifyTokenUsersVerifyTokenGet<TData = Awaited<ReturnType<typeof verifyTokenUsersVerifyTokenGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof verifyTokenUsersVerifyTokenGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof verifyTokenUsersVerifyTokenGet>>,
          TError,
          Awaited<ReturnType<typeof verifyTokenUsersVerifyTokenGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useVerifyTokenUsersVerifyTokenGet<TData = Awaited<ReturnType<typeof verifyTokenUsersVerifyTokenGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof verifyTokenUsersVerifyTokenGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof verifyTokenUsersVerifyTokenGet>>,
          TError,
          Awaited<ReturnType<typeof verifyTokenUsersVerifyTokenGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useVerifyTokenUsersVerifyTokenGet<TData = Awaited<ReturnType<typeof verifyTokenUsersVerifyTokenGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof verifyTokenUsersVerifyTokenGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Verify Token
 */

export function useVerifyTokenUsersVerifyTokenGet<TData = Awaited<ReturnType<typeof verifyTokenUsersVerifyTokenGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof verifyTokenUsersVerifyTokenGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getVerifyTokenUsersVerifyTokenGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 刷新token，生成新的access_token
前端可以在token即将过期时调用此接口
 * @summary Refresh Token
 */
export const refreshTokenUsersRefreshTokenPost = (
    
 signal?: AbortSignal
) => {
      
      
      return backend_api<LoginResponse>(
      {url: `/users/refresh-token`, method: 'POST', signal
    },
      );
    }
  


export const getRefreshTokenUsersRefreshTokenPostMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshTokenUsersRefreshTokenPost>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof refreshTokenUsersRefreshTokenPost>>, TError,void, TContext> => {

const mutationKey = ['refreshTokenUsersRefreshTokenPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof refreshTokenUsersRefreshTokenPost>>, void> = () => {
          

          return  refreshTokenUsersRefreshTokenPost()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RefreshTokenUsersRefreshTokenPostMutationResult = NonNullable<Awaited<ReturnType<typeof refreshTokenUsersRefreshTokenPost>>>
    
    export type RefreshTokenUsersRefreshTokenPostMutationError = unknown

    /**
 * @summary Refresh Token
 */
export const useRefreshTokenUsersRefreshTokenPost = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshTokenUsersRefreshTokenPost>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof refreshTokenUsersRefreshTokenPost>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getRefreshTokenUsersRefreshTokenPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get Current User Info
 */
export const getCurrentUserInfoUsersMeGet = (
    
 signal?: AbortSignal
) => {
      
      
      return backend_api<UserOut>(
      {url: `/users/me`, method: 'GET', signal
    },
      );
    }
  

export const getGetCurrentUserInfoUsersMeGetQueryKey = () => {
    return [`/users/me`] as const;
    }

    
export const getGetCurrentUserInfoUsersMeGetQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentUserInfoUsersMeGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>> = ({ signal }) => getCurrentUserInfoUsersMeGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentUserInfoUsersMeGetQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>>
export type GetCurrentUserInfoUsersMeGetQueryError = unknown


export function useGetCurrentUserInfoUsersMeGet<TData = Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>,
          TError,
          Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentUserInfoUsersMeGet<TData = Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>,
          TError,
          Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentUserInfoUsersMeGet<TData = Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Current User Info
 */

export function useGetCurrentUserInfoUsersMeGet<TData = Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentUserInfoUsersMeGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update Current User Info
 */
export const updateCurrentUserInfoUsersMePut = (
    userUpdate: UserUpdate,
 ) => {
      
      
      return backend_api<UserOut>(
      {url: `/users/me`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: userUpdate
    },
      );
    }
  


export const getUpdateCurrentUserInfoUsersMePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCurrentUserInfoUsersMePut>>, TError,{data: UserUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCurrentUserInfoUsersMePut>>, TError,{data: UserUpdate}, TContext> => {

const mutationKey = ['updateCurrentUserInfoUsersMePut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCurrentUserInfoUsersMePut>>, {data: UserUpdate}> = (props) => {
          const {data} = props ?? {};

          return  updateCurrentUserInfoUsersMePut(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCurrentUserInfoUsersMePutMutationResult = NonNullable<Awaited<ReturnType<typeof updateCurrentUserInfoUsersMePut>>>
    export type UpdateCurrentUserInfoUsersMePutMutationBody = UserUpdate
    export type UpdateCurrentUserInfoUsersMePutMutationError = HTTPValidationError

    /**
 * @summary Update Current User Info
 */
export const useUpdateCurrentUserInfoUsersMePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCurrentUserInfoUsersMePut>>, TError,{data: UserUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCurrentUserInfoUsersMePut>>,
        TError,
        {data: UserUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateCurrentUserInfoUsersMePutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Change Current User Password
 */
export const changeCurrentUserPasswordUsersMePasswordPut = (
    changePassword: ChangePassword,
 ) => {
      
      
      return backend_api<unknown>(
      {url: `/users/me/password`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: changePassword
    },
      );
    }
  


export const getChangeCurrentUserPasswordUsersMePasswordPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changeCurrentUserPasswordUsersMePasswordPut>>, TError,{data: ChangePassword}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof changeCurrentUserPasswordUsersMePasswordPut>>, TError,{data: ChangePassword}, TContext> => {

const mutationKey = ['changeCurrentUserPasswordUsersMePasswordPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof changeCurrentUserPasswordUsersMePasswordPut>>, {data: ChangePassword}> = (props) => {
          const {data} = props ?? {};

          return  changeCurrentUserPasswordUsersMePasswordPut(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChangeCurrentUserPasswordUsersMePasswordPutMutationResult = NonNullable<Awaited<ReturnType<typeof changeCurrentUserPasswordUsersMePasswordPut>>>
    export type ChangeCurrentUserPasswordUsersMePasswordPutMutationBody = ChangePassword
    export type ChangeCurrentUserPasswordUsersMePasswordPutMutationError = HTTPValidationError

    /**
 * @summary Change Current User Password
 */
export const useChangeCurrentUserPasswordUsersMePasswordPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changeCurrentUserPasswordUsersMePasswordPut>>, TError,{data: ChangePassword}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof changeCurrentUserPasswordUsersMePasswordPut>>,
        TError,
        {data: ChangePassword},
        TContext
      > => {

      const mutationOptions = getChangeCurrentUserPasswordUsersMePasswordPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get User Info
 */
export const getUserInfoUsersUserIdGet = (
    userId: string,
 signal?: AbortSignal
) => {
      
      
      return backend_api<UserOut>(
      {url: `/users/${userId}`, method: 'GET', signal
    },
      );
    }
  

export const getGetUserInfoUsersUserIdGetQueryKey = (userId: string,) => {
    return [`/users/${userId}`] as const;
    }

    
export const getGetUserInfoUsersUserIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>, TError = HTTPValidationError>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserInfoUsersUserIdGetQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>> = ({ signal }) => getUserInfoUsersUserIdGet(userId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserInfoUsersUserIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>>
export type GetUserInfoUsersUserIdGetQueryError = HTTPValidationError


export function useGetUserInfoUsersUserIdGet<TData = Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>, TError = HTTPValidationError>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>,
          TError,
          Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserInfoUsersUserIdGet<TData = Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>,
          TError,
          Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserInfoUsersUserIdGet<TData = Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get User Info
 */

export function useGetUserInfoUsersUserIdGet<TData = Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserInfoUsersUserIdGetQueryOptions(userId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update User Info
 */
export const updateUserInfoUsersUserIdPut = (
    userId: string,
    userUpdate: UserUpdate,
 ) => {
      
      
      return backend_api<UserOut>(
      {url: `/users/${userId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: userUpdate
    },
      );
    }
  


export const getUpdateUserInfoUsersUserIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserInfoUsersUserIdPut>>, TError,{userId: string;data: UserUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateUserInfoUsersUserIdPut>>, TError,{userId: string;data: UserUpdate}, TContext> => {

const mutationKey = ['updateUserInfoUsersUserIdPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUserInfoUsersUserIdPut>>, {userId: string;data: UserUpdate}> = (props) => {
          const {userId,data} = props ?? {};

          return  updateUserInfoUsersUserIdPut(userId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserInfoUsersUserIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateUserInfoUsersUserIdPut>>>
    export type UpdateUserInfoUsersUserIdPutMutationBody = UserUpdate
    export type UpdateUserInfoUsersUserIdPutMutationError = HTTPValidationError

    /**
 * @summary Update User Info
 */
export const useUpdateUserInfoUsersUserIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserInfoUsersUserIdPut>>, TError,{userId: string;data: UserUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateUserInfoUsersUserIdPut>>,
        TError,
        {userId: string;data: UserUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateUserInfoUsersUserIdPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Change Password
 */
export const changePasswordUsersUserIdPasswordPut = (
    userId: string,
    changePassword: ChangePassword,
 ) => {
      
      
      return backend_api<unknown>(
      {url: `/users/${userId}/password`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: changePassword
    },
      );
    }
  


export const getChangePasswordUsersUserIdPasswordPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changePasswordUsersUserIdPasswordPut>>, TError,{userId: string;data: ChangePassword}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof changePasswordUsersUserIdPasswordPut>>, TError,{userId: string;data: ChangePassword}, TContext> => {

const mutationKey = ['changePasswordUsersUserIdPasswordPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof changePasswordUsersUserIdPasswordPut>>, {userId: string;data: ChangePassword}> = (props) => {
          const {userId,data} = props ?? {};

          return  changePasswordUsersUserIdPasswordPut(userId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChangePasswordUsersUserIdPasswordPutMutationResult = NonNullable<Awaited<ReturnType<typeof changePasswordUsersUserIdPasswordPut>>>
    export type ChangePasswordUsersUserIdPasswordPutMutationBody = ChangePassword
    export type ChangePasswordUsersUserIdPasswordPutMutationError = HTTPValidationError

    /**
 * @summary Change Password
 */
export const useChangePasswordUsersUserIdPasswordPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changePasswordUsersUserIdPasswordPut>>, TError,{userId: string;data: ChangePassword}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof changePasswordUsersUserIdPasswordPut>>,
        TError,
        {userId: string;data: ChangePassword},
        TContext
      > => {

      const mutationOptions = getChangePasswordUsersUserIdPasswordPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 管理员获取所有用户列表
 * @summary Get All Users
 */
export const getAllUsersUsersAdminUsersGet = (
    params?: GetAllUsersUsersAdminUsersGetParams,
 signal?: AbortSignal
) => {
      
      
      return backend_api<UserListResponse>(
      {url: `/users/admin/users`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetAllUsersUsersAdminUsersGetQueryKey = (params?: GetAllUsersUsersAdminUsersGetParams,) => {
    return [`/users/admin/users`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAllUsersUsersAdminUsersGetQueryOptions = <TData = Awaited<ReturnType<typeof getAllUsersUsersAdminUsersGet>>, TError = HTTPValidationError>(params?: GetAllUsersUsersAdminUsersGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllUsersUsersAdminUsersGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllUsersUsersAdminUsersGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllUsersUsersAdminUsersGet>>> = ({ signal }) => getAllUsersUsersAdminUsersGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllUsersUsersAdminUsersGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllUsersUsersAdminUsersGetQueryResult = NonNullable<Awaited<ReturnType<typeof getAllUsersUsersAdminUsersGet>>>
export type GetAllUsersUsersAdminUsersGetQueryError = HTTPValidationError


export function useGetAllUsersUsersAdminUsersGet<TData = Awaited<ReturnType<typeof getAllUsersUsersAdminUsersGet>>, TError = HTTPValidationError>(
 params: undefined |  GetAllUsersUsersAdminUsersGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllUsersUsersAdminUsersGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllUsersUsersAdminUsersGet>>,
          TError,
          Awaited<ReturnType<typeof getAllUsersUsersAdminUsersGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllUsersUsersAdminUsersGet<TData = Awaited<ReturnType<typeof getAllUsersUsersAdminUsersGet>>, TError = HTTPValidationError>(
 params?: GetAllUsersUsersAdminUsersGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllUsersUsersAdminUsersGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllUsersUsersAdminUsersGet>>,
          TError,
          Awaited<ReturnType<typeof getAllUsersUsersAdminUsersGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllUsersUsersAdminUsersGet<TData = Awaited<ReturnType<typeof getAllUsersUsersAdminUsersGet>>, TError = HTTPValidationError>(
 params?: GetAllUsersUsersAdminUsersGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllUsersUsersAdminUsersGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get All Users
 */

export function useGetAllUsersUsersAdminUsersGet<TData = Awaited<ReturnType<typeof getAllUsersUsersAdminUsersGet>>, TError = HTTPValidationError>(
 params?: GetAllUsersUsersAdminUsersGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllUsersUsersAdminUsersGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllUsersUsersAdminUsersGetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 管理员创建新用户
 * @summary Create User By Admin
 */
export const createUserByAdminUsersAdminUsersPost = (
    adminUserCreate: AdminUserCreate,
 signal?: AbortSignal
) => {
      
      
      return backend_api<UserOut>(
      {url: `/users/admin/users`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: adminUserCreate, signal
    },
      );
    }
  


export const getCreateUserByAdminUsersAdminUsersPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUserByAdminUsersAdminUsersPost>>, TError,{data: AdminUserCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createUserByAdminUsersAdminUsersPost>>, TError,{data: AdminUserCreate}, TContext> => {

const mutationKey = ['createUserByAdminUsersAdminUsersPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUserByAdminUsersAdminUsersPost>>, {data: AdminUserCreate}> = (props) => {
          const {data} = props ?? {};

          return  createUserByAdminUsersAdminUsersPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateUserByAdminUsersAdminUsersPostMutationResult = NonNullable<Awaited<ReturnType<typeof createUserByAdminUsersAdminUsersPost>>>
    export type CreateUserByAdminUsersAdminUsersPostMutationBody = AdminUserCreate
    export type CreateUserByAdminUsersAdminUsersPostMutationError = HTTPValidationError

    /**
 * @summary Create User By Admin
 */
export const useCreateUserByAdminUsersAdminUsersPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUserByAdminUsersAdminUsersPost>>, TError,{data: AdminUserCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createUserByAdminUsersAdminUsersPost>>,
        TError,
        {data: AdminUserCreate},
        TContext
      > => {

      const mutationOptions = getCreateUserByAdminUsersAdminUsersPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 管理员获取指定用户信息
 * @summary Get User By Admin
 */
export const getUserByAdminUsersAdminUsersUserIdGet = (
    userId: string,
 signal?: AbortSignal
) => {
      
      
      return backend_api<UserOut>(
      {url: `/users/admin/users/${userId}`, method: 'GET', signal
    },
      );
    }
  

export const getGetUserByAdminUsersAdminUsersUserIdGetQueryKey = (userId: string,) => {
    return [`/users/admin/users/${userId}`] as const;
    }

    
export const getGetUserByAdminUsersAdminUsersUserIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getUserByAdminUsersAdminUsersUserIdGet>>, TError = HTTPValidationError>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserByAdminUsersAdminUsersUserIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserByAdminUsersAdminUsersUserIdGetQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserByAdminUsersAdminUsersUserIdGet>>> = ({ signal }) => getUserByAdminUsersAdminUsersUserIdGet(userId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserByAdminUsersAdminUsersUserIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserByAdminUsersAdminUsersUserIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUserByAdminUsersAdminUsersUserIdGet>>>
export type GetUserByAdminUsersAdminUsersUserIdGetQueryError = HTTPValidationError


export function useGetUserByAdminUsersAdminUsersUserIdGet<TData = Awaited<ReturnType<typeof getUserByAdminUsersAdminUsersUserIdGet>>, TError = HTTPValidationError>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserByAdminUsersAdminUsersUserIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserByAdminUsersAdminUsersUserIdGet>>,
          TError,
          Awaited<ReturnType<typeof getUserByAdminUsersAdminUsersUserIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserByAdminUsersAdminUsersUserIdGet<TData = Awaited<ReturnType<typeof getUserByAdminUsersAdminUsersUserIdGet>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserByAdminUsersAdminUsersUserIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserByAdminUsersAdminUsersUserIdGet>>,
          TError,
          Awaited<ReturnType<typeof getUserByAdminUsersAdminUsersUserIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserByAdminUsersAdminUsersUserIdGet<TData = Awaited<ReturnType<typeof getUserByAdminUsersAdminUsersUserIdGet>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserByAdminUsersAdminUsersUserIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get User By Admin
 */

export function useGetUserByAdminUsersAdminUsersUserIdGet<TData = Awaited<ReturnType<typeof getUserByAdminUsersAdminUsersUserIdGet>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserByAdminUsersAdminUsersUserIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserByAdminUsersAdminUsersUserIdGetQueryOptions(userId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 管理员更新用户信息
 * @summary Update User By Admin
 */
export const updateUserByAdminUsersAdminUsersUserIdPut = (
    userId: string,
    adminUserUpdate: AdminUserUpdate,
 ) => {
      
      
      return backend_api<UserOut>(
      {url: `/users/admin/users/${userId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: adminUserUpdate
    },
      );
    }
  


export const getUpdateUserByAdminUsersAdminUsersUserIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserByAdminUsersAdminUsersUserIdPut>>, TError,{userId: string;data: AdminUserUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateUserByAdminUsersAdminUsersUserIdPut>>, TError,{userId: string;data: AdminUserUpdate}, TContext> => {

const mutationKey = ['updateUserByAdminUsersAdminUsersUserIdPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUserByAdminUsersAdminUsersUserIdPut>>, {userId: string;data: AdminUserUpdate}> = (props) => {
          const {userId,data} = props ?? {};

          return  updateUserByAdminUsersAdminUsersUserIdPut(userId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserByAdminUsersAdminUsersUserIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateUserByAdminUsersAdminUsersUserIdPut>>>
    export type UpdateUserByAdminUsersAdminUsersUserIdPutMutationBody = AdminUserUpdate
    export type UpdateUserByAdminUsersAdminUsersUserIdPutMutationError = HTTPValidationError

    /**
 * @summary Update User By Admin
 */
export const useUpdateUserByAdminUsersAdminUsersUserIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserByAdminUsersAdminUsersUserIdPut>>, TError,{userId: string;data: AdminUserUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateUserByAdminUsersAdminUsersUserIdPut>>,
        TError,
        {userId: string;data: AdminUserUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateUserByAdminUsersAdminUsersUserIdPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * 管理员删除用户
 * @summary Delete User By Admin
 */
export const deleteUserByAdminUsersAdminUsersUserIdDelete = (
    userId: string,
 ) => {
      
      
      return backend_api<unknown>(
      {url: `/users/admin/users/${userId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteUserByAdminUsersAdminUsersUserIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUserByAdminUsersAdminUsersUserIdDelete>>, TError,{userId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteUserByAdminUsersAdminUsersUserIdDelete>>, TError,{userId: string}, TContext> => {

const mutationKey = ['deleteUserByAdminUsersAdminUsersUserIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUserByAdminUsersAdminUsersUserIdDelete>>, {userId: string}> = (props) => {
          const {userId} = props ?? {};

          return  deleteUserByAdminUsersAdminUsersUserIdDelete(userId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserByAdminUsersAdminUsersUserIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUserByAdminUsersAdminUsersUserIdDelete>>>
    
    export type DeleteUserByAdminUsersAdminUsersUserIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete User By Admin
 */
export const useDeleteUserByAdminUsersAdminUsersUserIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUserByAdminUsersAdminUsersUserIdDelete>>, TError,{userId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteUserByAdminUsersAdminUsersUserIdDelete>>,
        TError,
        {userId: string},
        TContext
      > => {

      const mutationOptions = getDeleteUserByAdminUsersAdminUsersUserIdDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
