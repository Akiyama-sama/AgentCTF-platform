/**
 * Generated by orval v7.9.0 ðŸº
 * Do not edit manually.
 * Attack Monitor Backend API
 * æ”»å‡»ç›‘æŽ§ç³»ç»ŸåŽç«¯APIæŽ¥å£
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { backend_api } from '../utils/backend-api';
export interface ChangePassword {
  old_password: string;
  new_password: string;
}

export interface EmailRequest {
  email: string;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export type PermissionDescription = string | null;

export interface Permission {
  name: string;
  description?: PermissionDescription;
  id: number;
  created_time: string;
}

export interface RefreshToken {
  refresh_token: string;
}

export interface RegisterRequest {
  email: string;
  username: string;
  password: string;
  code: string;
}

export type RoleDescription = string | null;

export interface Role {
  name: string;
  description?: RoleDescription;
  id: number;
  created_time: string;
  permissions?: Permission[];
}

export interface Token {
  access_token: string;
  token_type: string;
  refresh_token: string;
}

export interface UserLogin {
  username_or_email: string;
  password: string;
}

export interface UserOut {
  username: string;
  email: string;
  id: string;
  is_active: boolean;
  is_verified: boolean;
  created_time: string;
  roles?: Role[];
}

export type UserUpdateUsername = string | null;

export type UserUpdateEmail = string | null;

export interface UserUpdate {
  username?: UserUpdateUsername;
  email?: UserUpdateEmail;
}

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

/**
 * @summary Register
 */
export const registerUsersRegisterPost = (
    registerRequest: RegisterRequest,
 signal?: AbortSignal
) => {
      
      
      return backend_api<UserOut>(
      {url: `/users/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: registerRequest, signal
    },
      );
    }
  


export const getRegisterUsersRegisterPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerUsersRegisterPost>>, TError,{data: RegisterRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof registerUsersRegisterPost>>, TError,{data: RegisterRequest}, TContext> => {

const mutationKey = ['registerUsersRegisterPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registerUsersRegisterPost>>, {data: RegisterRequest}> = (props) => {
          const {data} = props ?? {};

          return  registerUsersRegisterPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterUsersRegisterPostMutationResult = NonNullable<Awaited<ReturnType<typeof registerUsersRegisterPost>>>
    export type RegisterUsersRegisterPostMutationBody = RegisterRequest
    export type RegisterUsersRegisterPostMutationError = HTTPValidationError

    /**
 * @summary Register
 */
export const useRegisterUsersRegisterPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerUsersRegisterPost>>, TError,{data: RegisterRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof registerUsersRegisterPost>>,
        TError,
        {data: RegisterRequest},
        TContext
      > => {

      const mutationOptions = getRegisterUsersRegisterPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Login
 */
export const loginUsersLoginPost = (
    userLogin: UserLogin,
 signal?: AbortSignal
) => {
      
      
      return backend_api<Token>(
      {url: `/users/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userLogin, signal
    },
      );
    }
  


export const getLoginUsersLoginPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginUsersLoginPost>>, TError,{data: UserLogin}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof loginUsersLoginPost>>, TError,{data: UserLogin}, TContext> => {

const mutationKey = ['loginUsersLoginPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginUsersLoginPost>>, {data: UserLogin}> = (props) => {
          const {data} = props ?? {};

          return  loginUsersLoginPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginUsersLoginPostMutationResult = NonNullable<Awaited<ReturnType<typeof loginUsersLoginPost>>>
    export type LoginUsersLoginPostMutationBody = UserLogin
    export type LoginUsersLoginPostMutationError = HTTPValidationError

    /**
 * @summary Login
 */
export const useLoginUsersLoginPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginUsersLoginPost>>, TError,{data: UserLogin}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof loginUsersLoginPost>>,
        TError,
        {data: UserLogin},
        TContext
      > => {

      const mutationOptions = getLoginUsersLoginPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Refresh Token
 */
export const refreshTokenUsersRefreshPost = (
    refreshToken: RefreshToken,
 signal?: AbortSignal
) => {
      
      
      return backend_api<Token>(
      {url: `/users/refresh`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: refreshToken, signal
    },
      );
    }
  


export const getRefreshTokenUsersRefreshPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshTokenUsersRefreshPost>>, TError,{data: RefreshToken}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof refreshTokenUsersRefreshPost>>, TError,{data: RefreshToken}, TContext> => {

const mutationKey = ['refreshTokenUsersRefreshPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof refreshTokenUsersRefreshPost>>, {data: RefreshToken}> = (props) => {
          const {data} = props ?? {};

          return  refreshTokenUsersRefreshPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RefreshTokenUsersRefreshPostMutationResult = NonNullable<Awaited<ReturnType<typeof refreshTokenUsersRefreshPost>>>
    export type RefreshTokenUsersRefreshPostMutationBody = RefreshToken
    export type RefreshTokenUsersRefreshPostMutationError = HTTPValidationError

    /**
 * @summary Refresh Token
 */
export const useRefreshTokenUsersRefreshPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshTokenUsersRefreshPost>>, TError,{data: RefreshToken}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof refreshTokenUsersRefreshPost>>,
        TError,
        {data: RefreshToken},
        TContext
      > => {

      const mutationOptions = getRefreshTokenUsersRefreshPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Logout
 */
export const logoutUsersLogoutPost = (
    refreshToken: RefreshToken,
 signal?: AbortSignal
) => {
      
      
      return backend_api<unknown>(
      {url: `/users/logout`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: refreshToken, signal
    },
      );
    }
  


export const getLogoutUsersLogoutPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logoutUsersLogoutPost>>, TError,{data: RefreshToken}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof logoutUsersLogoutPost>>, TError,{data: RefreshToken}, TContext> => {

const mutationKey = ['logoutUsersLogoutPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof logoutUsersLogoutPost>>, {data: RefreshToken}> = (props) => {
          const {data} = props ?? {};

          return  logoutUsersLogoutPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LogoutUsersLogoutPostMutationResult = NonNullable<Awaited<ReturnType<typeof logoutUsersLogoutPost>>>
    export type LogoutUsersLogoutPostMutationBody = RefreshToken
    export type LogoutUsersLogoutPostMutationError = HTTPValidationError

    /**
 * @summary Logout
 */
export const useLogoutUsersLogoutPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logoutUsersLogoutPost>>, TError,{data: RefreshToken}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof logoutUsersLogoutPost>>,
        TError,
        {data: RefreshToken},
        TContext
      > => {

      const mutationOptions = getLogoutUsersLogoutPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Request Verification
 */
export const requestVerificationUsersRequestVerificationPost = (
    emailRequest: EmailRequest,
 signal?: AbortSignal
) => {
      
      
      return backend_api<unknown>(
      {url: `/users/request-verification`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: emailRequest, signal
    },
      );
    }
  


export const getRequestVerificationUsersRequestVerificationPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof requestVerificationUsersRequestVerificationPost>>, TError,{data: EmailRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof requestVerificationUsersRequestVerificationPost>>, TError,{data: EmailRequest}, TContext> => {

const mutationKey = ['requestVerificationUsersRequestVerificationPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof requestVerificationUsersRequestVerificationPost>>, {data: EmailRequest}> = (props) => {
          const {data} = props ?? {};

          return  requestVerificationUsersRequestVerificationPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RequestVerificationUsersRequestVerificationPostMutationResult = NonNullable<Awaited<ReturnType<typeof requestVerificationUsersRequestVerificationPost>>>
    export type RequestVerificationUsersRequestVerificationPostMutationBody = EmailRequest
    export type RequestVerificationUsersRequestVerificationPostMutationError = HTTPValidationError

    /**
 * @summary Request Verification
 */
export const useRequestVerificationUsersRequestVerificationPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof requestVerificationUsersRequestVerificationPost>>, TError,{data: EmailRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof requestVerificationUsersRequestVerificationPost>>,
        TError,
        {data: EmailRequest},
        TContext
      > => {

      const mutationOptions = getRequestVerificationUsersRequestVerificationPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get User Info
 */
export const getUserInfoUsersUserIdGet = (
    userId: string,
 signal?: AbortSignal
) => {
      
      
      return backend_api<UserOut>(
      {url: `/users/${userId}`, method: 'GET', signal
    },
      );
    }
  

export const getGetUserInfoUsersUserIdGetQueryKey = (userId: string,) => {
    return [`/users/${userId}`] as const;
    }

    
export const getGetUserInfoUsersUserIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>, TError = HTTPValidationError>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserInfoUsersUserIdGetQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>> = ({ signal }) => getUserInfoUsersUserIdGet(userId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserInfoUsersUserIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>>
export type GetUserInfoUsersUserIdGetQueryError = HTTPValidationError


export function useGetUserInfoUsersUserIdGet<TData = Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>, TError = HTTPValidationError>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>,
          TError,
          Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserInfoUsersUserIdGet<TData = Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>,
          TError,
          Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserInfoUsersUserIdGet<TData = Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get User Info
 */

export function useGetUserInfoUsersUserIdGet<TData = Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserInfoUsersUserIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserInfoUsersUserIdGetQueryOptions(userId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update User Info
 */
export const updateUserInfoUsersUserIdPut = (
    userId: string,
    userUpdate: UserUpdate,
 ) => {
      
      
      return backend_api<UserOut>(
      {url: `/users/${userId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: userUpdate
    },
      );
    }
  


export const getUpdateUserInfoUsersUserIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserInfoUsersUserIdPut>>, TError,{userId: string;data: UserUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateUserInfoUsersUserIdPut>>, TError,{userId: string;data: UserUpdate}, TContext> => {

const mutationKey = ['updateUserInfoUsersUserIdPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUserInfoUsersUserIdPut>>, {userId: string;data: UserUpdate}> = (props) => {
          const {userId,data} = props ?? {};

          return  updateUserInfoUsersUserIdPut(userId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserInfoUsersUserIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateUserInfoUsersUserIdPut>>>
    export type UpdateUserInfoUsersUserIdPutMutationBody = UserUpdate
    export type UpdateUserInfoUsersUserIdPutMutationError = HTTPValidationError

    /**
 * @summary Update User Info
 */
export const useUpdateUserInfoUsersUserIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserInfoUsersUserIdPut>>, TError,{userId: string;data: UserUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateUserInfoUsersUserIdPut>>,
        TError,
        {userId: string;data: UserUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateUserInfoUsersUserIdPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Change Password
 */
export const changePasswordUsersUserIdPasswordPut = (
    userId: string,
    changePassword: ChangePassword,
 ) => {
      
      
      return backend_api<unknown>(
      {url: `/users/${userId}/password`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: changePassword
    },
      );
    }
  


export const getChangePasswordUsersUserIdPasswordPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changePasswordUsersUserIdPasswordPut>>, TError,{userId: string;data: ChangePassword}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof changePasswordUsersUserIdPasswordPut>>, TError,{userId: string;data: ChangePassword}, TContext> => {

const mutationKey = ['changePasswordUsersUserIdPasswordPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof changePasswordUsersUserIdPasswordPut>>, {userId: string;data: ChangePassword}> = (props) => {
          const {userId,data} = props ?? {};

          return  changePasswordUsersUserIdPasswordPut(userId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChangePasswordUsersUserIdPasswordPutMutationResult = NonNullable<Awaited<ReturnType<typeof changePasswordUsersUserIdPasswordPut>>>
    export type ChangePasswordUsersUserIdPasswordPutMutationBody = ChangePassword
    export type ChangePasswordUsersUserIdPasswordPutMutationError = HTTPValidationError

    /**
 * @summary Change Password
 */
export const useChangePasswordUsersUserIdPasswordPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changePasswordUsersUserIdPasswordPut>>, TError,{userId: string;data: ChangePassword}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof changePasswordUsersUserIdPasswordPut>>,
        TError,
        {userId: string;data: ChangePassword},
        TContext
      > => {

      const mutationOptions = getChangePasswordUsersUserIdPasswordPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get Current User Info
 */
export const getCurrentUserInfoUsersMeGet = (
    
 signal?: AbortSignal
) => {
      
      
      return backend_api<UserOut>(
      {url: `/users/me`, method: 'GET', signal
    },
      );
    }
  

export const getGetCurrentUserInfoUsersMeGetQueryKey = () => {
    return [`/users/me`] as const;
    }

    
export const getGetCurrentUserInfoUsersMeGetQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentUserInfoUsersMeGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>> = ({ signal }) => getCurrentUserInfoUsersMeGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentUserInfoUsersMeGetQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>>
export type GetCurrentUserInfoUsersMeGetQueryError = unknown


export function useGetCurrentUserInfoUsersMeGet<TData = Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>,
          TError,
          Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentUserInfoUsersMeGet<TData = Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>,
          TError,
          Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentUserInfoUsersMeGet<TData = Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Current User Info
 */

export function useGetCurrentUserInfoUsersMeGet<TData = Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUserInfoUsersMeGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentUserInfoUsersMeGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update Current User Info
 */
export const updateCurrentUserInfoUsersMePut = (
    userUpdate: UserUpdate,
 ) => {
      
      
      return backend_api<UserOut>(
      {url: `/users/me`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: userUpdate
    },
      );
    }
  


export const getUpdateCurrentUserInfoUsersMePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCurrentUserInfoUsersMePut>>, TError,{data: UserUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCurrentUserInfoUsersMePut>>, TError,{data: UserUpdate}, TContext> => {

const mutationKey = ['updateCurrentUserInfoUsersMePut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCurrentUserInfoUsersMePut>>, {data: UserUpdate}> = (props) => {
          const {data} = props ?? {};

          return  updateCurrentUserInfoUsersMePut(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCurrentUserInfoUsersMePutMutationResult = NonNullable<Awaited<ReturnType<typeof updateCurrentUserInfoUsersMePut>>>
    export type UpdateCurrentUserInfoUsersMePutMutationBody = UserUpdate
    export type UpdateCurrentUserInfoUsersMePutMutationError = HTTPValidationError

    /**
 * @summary Update Current User Info
 */
export const useUpdateCurrentUserInfoUsersMePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCurrentUserInfoUsersMePut>>, TError,{data: UserUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCurrentUserInfoUsersMePut>>,
        TError,
        {data: UserUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateCurrentUserInfoUsersMePutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Change Current User Password
 */
export const changeCurrentUserPasswordUsersMePasswordPut = (
    changePassword: ChangePassword,
 ) => {
      
      
      return backend_api<unknown>(
      {url: `/users/me/password`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: changePassword
    },
      );
    }
  


export const getChangeCurrentUserPasswordUsersMePasswordPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changeCurrentUserPasswordUsersMePasswordPut>>, TError,{data: ChangePassword}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof changeCurrentUserPasswordUsersMePasswordPut>>, TError,{data: ChangePassword}, TContext> => {

const mutationKey = ['changeCurrentUserPasswordUsersMePasswordPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof changeCurrentUserPasswordUsersMePasswordPut>>, {data: ChangePassword}> = (props) => {
          const {data} = props ?? {};

          return  changeCurrentUserPasswordUsersMePasswordPut(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChangeCurrentUserPasswordUsersMePasswordPutMutationResult = NonNullable<Awaited<ReturnType<typeof changeCurrentUserPasswordUsersMePasswordPut>>>
    export type ChangeCurrentUserPasswordUsersMePasswordPutMutationBody = ChangePassword
    export type ChangeCurrentUserPasswordUsersMePasswordPutMutationError = HTTPValidationError

    /**
 * @summary Change Current User Password
 */
export const useChangeCurrentUserPasswordUsersMePasswordPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changeCurrentUserPasswordUsersMePasswordPut>>, TError,{data: ChangePassword}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof changeCurrentUserPasswordUsersMePasswordPut>>,
        TError,
        {data: ChangePassword},
        TContext
      > => {

      const mutationOptions = getChangeCurrentUserPasswordUsersMePasswordPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
